# DoomsdaySSW3 游戏技术规范文档 (SPEC)

## 文档版本
- **版本号**: v1.0
- **创建日期**: 2024-12-10
- **项目名称**: DoomsdaySSW3
- **游戏类型**: 回合制探索挖矿 + 勘探船建造 + 卡牌构建
- **开发引擎**: Unity 2021.3.40f1

---

## 1. 项目概述

### 1.1 游戏核心玩法
一款以回合制探索、资源挖矿、勘探船建造和卡牌构建为核心玩法的太空勘探游戏。玩家需要管理勘探船，在地图上探索挖矿点，挖掘矿物资源，升级勘探船，并应对虫族威胁。

### 1.2 核心循环
0. **初始选择阶段**（仅游戏开始时）：选择勘探船并应用合同效果（详见第2章）
1. **移动阶段**: 在大地图上点击探索点，勘探船直接移动到目标探索点
2. **准备阶段**: 到达探索点后，创建队伍选择进入探索点的角色（**至少1人，最多3人**）和角色使用的工具
3. **探索阶段**: 进入探索点内部，进行挖矿和战斗
4. **战斗/挖矿阶段**: 在探索点中挖掘矿物资源、躲避或消灭虫族
5. **返回阶段**: 返回勘探船保存资源
6. **功能解锁阶段**: 在勘探船中消耗资源解锁章节功能，推进主线剧情
7. **回合推进**: 点击"下一回合"进入下一轮循环

---

## 2. 初始勘探船选择系统

### 2.1 系统概述

在游戏开始前，玩家需要从三艘勘探船中选择一艘租用。每艘勘探船都有独特的租用合同，合同决定游戏的初始条件、难度和特殊机制。

**核心设计理念**：
- **初始选择**：游戏开始时玩家必须选择一艘勘探船
- **合同系统**：每艘船对应一个租用合同，合同包含难度标注、初始奖励、限制条件和特殊规则
- **难度差异化**：不同合同提供不同的游戏难度和体验
- **一次性选择**：合同选择仅在游戏开始时进行，选择后不可更改（除非重新开始游戏）

### 2.2 勘探船选择流程

```
游戏启动
    ↓
显示勘探船选择界面
    ↓
展示三艘勘探船信息（名称、外观、难度、合同摘要）
    ↓
玩家选择一艘勘探船
    ↓
显示完整租用合同详情
    ↓
玩家确认选择
    ↓
应用合同效果（初始资源、限制条件、特殊规则）
    ↓
进入游戏主界面
```

### 2.3 租用合同内容

#### 2.3.1 难度标注
- **难度等级**：简单/普通/困难（或使用1-5星等级）
- **难度影响**：难度影响游戏的整体挑战性，可能体现在：
  - 初始资源数量
  - 敌人强度
  - 资源获取率
  - 特殊挑战条件
  - 其他游戏机制调整

#### 2.3.2 初始奖励
- **初始资源**：租用该船时，勘探船仓库中获得的初始矿物资源
- **初始角色**：某些合同可能提供初始角色（可选）
- **初始解锁功能**：某些合同可能解锁特定功能（可选）

#### 2.3.3 限制条件
- **资源上限**：某些合同可能限制仓库容量
- **角色限制**：某些合同可能限制可招募角色数量或类型
- **其他限制**：如回合数限制、探索点限制等（可选）

#### 2.3.4 特殊规则
- **特殊机制**：该船独有的特殊机制（如独特的资源获取方式、特殊能力等）
- **特殊挑战**：该船可能带来的额外挑战条件

### 2.4 勘探船数据结构扩展

```csharp
// 伪代码结构
ProspectingShip {
    string shipId;                  // 勘探船ID
    string contractId;              // 租用合同ID
    DifficultyLevel difficulty;     // 难度等级
    string currentChapterId;        // 当前所属章节ID
    List<string> unlockedFeatures;    // 已解锁的功能ID列表
    Map<string, int> warehouse;       // 仓库资源（资源ID -> 数量）
    ShipAppearance appearance;      // 当前勘探船外观（根据章节变化）
    List<Explorer> members;          // 成员列表（最多3人），固定在勘探船上
    Vector2Int currentPosition;      // 当前位置（勘探船位置）
    ShipStatus status;                // 勘探船状态：停靠中/移动中/探索中/返回中
    ContractRestrictions activeRestrictions; // 当前生效的合同限制条件
    ContractSpecialRules activeSpecialRules; // 当前生效的合同特殊规则
}

ShipContract {
    string contractId;              // 合同ID
    string shipId;                  // 对应的勘探船ID
    string nameKey;                 // 合同名称（多语言Key）
    string descKey;                 // 合同描述（多语言Key）
    DifficultyLevel difficulty;     // 难度等级
    ContractRewards initialRewards; // 初始奖励
    ContractRestrictions restrictions; // 限制条件
    ContractSpecialRules specialRules; // 特殊规则
}

ContractRewards {
    Map<string, int> initialResources; // 初始资源（资源ID -> 数量）
    List<string> initialExplorerIds;    // 初始角色ID列表（可选）
    List<string> initialUnlockedFeatures; // 初始解锁功能ID列表（可选）
}

ContractRestrictions {
    int? maxWarehouseCapacity;      // 仓库容量上限（可选，null表示无限制）
    int? maxExplorerCount;         // 最大角色数量（可选，null表示无限制）
    List<string> restrictedExplorerIds; // 限制招募的角色ID列表（可选）
    // 其他限制条件...
}

ContractSpecialRules {
    string ruleType;               // 规则类型（如"doubleResource"、"hardMode"等）
    Map<string, any> ruleParams;  // 规则参数
}

DifficultyLevel {
    Easy,      // 简单
    Normal,    // 普通
    Hard,      // 困难
    // 或使用1-5星等级
}
```

### 2.5 合同应用流程

#### 2.5.1 合同生效时机
- 合同在玩家确认选择后立即生效
- 合同效果在游戏初始化时应用

#### 2.5.2 初始奖励应用
1. **初始资源**：直接添加到勘探船仓库（`ProspectingShip.warehouse`）
2. **初始角色**：将角色添加到玩家角色列表中，并设置为已解锁状态
3. **初始解锁功能**：将功能添加到已解锁功能列表（`ProspectingShip.unlockedFeatures`）

#### 2.5.3 限制条件应用
- 限制条件在游戏过程中持续生效
- 系统需要在相关操作时检查限制条件（如招募角色时检查角色限制）

#### 2.5.4 特殊规则应用
- 特殊规则在游戏过程中持续生效
- 需要在相关系统（如资源系统、战斗系统等）中实现特殊规则的逻辑

### 2.6 UI设计要点

#### 2.6.1 勘探船选择界面
- **船体展示**：展示三艘船的外观、名称
- **难度标识**：使用颜色或图标清晰标识难度等级
- **合同摘要**：显示合同的关键信息（难度、主要奖励、主要限制）

#### 2.6.2 合同详情界面
- **完整信息**：显示完整的合同内容
- **奖励列表**：清晰展示初始奖励（资源、角色、功能）
- **限制说明**：明确说明所有限制条件
- **特殊规则**：详细说明特殊规则的效果

---

## 3. 时间系统设计

### 3.1 时间规则
- **回合时长**: 每个回合 = 30分钟（游戏内时间）
- **游戏内1天**: 48个回合（24小时 × 2回合/小时）
- **时间推进**: 手动触发，玩家点击"下一回合"才推进
- **暂停状态**: 未点击"下一回合"时，时间暂停，但回合内逻辑继续运行

### 3.2 时间段划分
| 时间段 | 时间范围 | 回合范围（刻度索引） | 特殊规则 |
|--------|----------|----------------------|----------|
| **白天** | 06:00 - 18:00 | 刻度 12-35（共24格） | 正常探索，虫族出现率低 |
| **傍晚** | 18:00 - 22:00 | 刻度 36-43（共8格） | 虫族出现率中等 |
| **深夜** | 22:00 - 次日06:00 | 刻度 44-47 + 0-11（共16格） | 返回路径大概率遇到虫族 |

> 刻度索引从 0 开始，每格代表 30 分钟（1回合）。UI 上使用不同颜色区分时间段：白天（白色）、傍晚（橙色）、深夜（紫色）。

### 3.3 时间系统数据结构
```csharp
// 伪代码结构
TimeSystem {
    int currentRound;          // 当前回合数 (0-47)
    int currentDay;            // 当前天数
    TimePeriod currentPeriod;  // 当前时间段 (Day/Evening/Night)
    bool isPaused;             // 是否暂停
    float roundDuration;       // 回合时长（30分钟）
}
```

---

## 4. 回合系统设计

### 4.1 回合运作流程
```
进入新回合（在回合开始时统一结算体力）
    ↓
临时背包恢复锁定状态并清空（上一回合的临时背包物品丢失，`isTempInventoryLocked = true`）
    ↓
角色状态刷新（体力-1，状态恢复等；**体力扣除仅在此处结算一次**）
    ↓
地点状态和配置刷新（资源刷新、怪物刷新等）
    ↓
根据当前所在位置与状态分支处理：
    ├─ 若在**大地图上且已选择目标点**：本回合在大地图上朝目标点移动1格
    └─ 若当前位于**探索点内部（探索空间中）**：本回合停留在原地，仅在探索空间内进行行动或层数推进，不进行大地图移动
    ↓
探险内计算（移动、探索、战斗等；不再额外扣除“每回合-1”的体力）
    ↓
玩家可手动使用道具
    ↓
玩家可整理背包（如果临时背包已解锁，可在角色背包和临时背包间移动非矿物物品；矿物资源已直接存储在勘探船仓库中）
    ↓
玩家可选择"退出"退出探索点，队伍解散，返回大地图（可在任意时刻选择，详见8.6退出探索点机制）
    ↓
玩家主动点击"下一回合"（进入下一回合，临时背包恢复锁定并清空）
```

### 4.2 回合状态机
- **RoundStart**: 回合开始
- **StateRefresh**: 状态刷新
- **LocationRefresh**: 地点刷新
- **Exploration**: 探索阶段
- **PlayerAction**: 玩家操作阶段
- **RoundEnd**: 回合结束（等待玩家点击下一回合）

---

## 5. 地图系统设计

### 5.1 地图网格系统
- **基础单位**: 格子（Grid Cell）
- **坐标系统**: 
  - 地图使用 X/Y 坐标系统
  - UI 渲染时，X 轴为垂直方向（行），Y 轴为水平方向（列）
  - 即：外层循环 X（每行一个 X 值），内层循环 Y（每列一个 Y 值）
- **移动规则**: 每回合在大地图上移动1格（仅当勘探船处于大地图状态且设置了目标点时生效；当勘探船正在探索点内部时，本回合不进行大地图格子的移动）
- **寻路规则**: 使用 BFS（广度优先搜索）进行 4 向寻路（上下左右），避开不可通行的格子
- **格子类型**: 
  - 勘探船停靠点（ProspectingShipDock）：可通行，勘探船起始点和返回目标
  - 道路（Road）：可通行
  - 探索点（Exploration Point）：可通行，可进入探索（挖矿点）
  - 空地（Empty）：可通行
  - 已建设地点（Built Location）：**不可通行**，寻路时需绕开

### 5.2 格子状态转换
```
探索点 (Exploration Point)
    ↓ [探索进度达到100%]
空地 (Empty)
    ↓ [满足建设条件 + 玩家操作]
已建设地点 (Built Location)
```

### 5.3 格子数据结构
```csharp
GridCell {
    CellType type;              // 格子类型
    Vector2Int position;         // 坐标位置
    ExplorationState exploreState; // 探索状态
    int explorationProgress;     // 探索进度 (0-100)，由当前层数 / 最大层数计算，例如 explorationProgress = currentLayer / maxLayers * 100
    bool canBuild;               // 是否可建设
    BuildingType buildingType;   // 建设类型（如果已建设）
    List<Resource> resources;    // 资源列表
    List<Monster> monsters;      // 怪物列表
    TimePeriod spawnTime;        // 生成时间段
    
    // 角色死亡物品存储（详见8.4角色死亡处理）
    List<Item> droppedItems;     // 死亡角色掉落的物品列表
    int deathRound;              // 角色死亡时的回合数（用于计算96回合过期）
    string deadExplorerId;       // 死亡角色的ID（用于显示和标识）
}
```

### 5.4 地图配置
- **地图大小**: 可配置（建议初始50x50）
- **初始勘探船位置**: 地图中心或指定坐标
- **探索点分布**: 策划配置表控制
- **道路连接**: 格子之间的移动路径

---

## 6. 探险者系统设计

### 6.1 探险者基础属性
| 属性 | 初始值 | 说明 |
|------|--------|------|
| **最大血量 (Max HP)** | 3点 | 角色的血量上限 |
| **初始血量 (Initial HP)** | 3点 | 角色首次被创建/解锁并加入玩家列表时的初始血量，用于初始化 currentHP，默认等于最大血量 |
| **最大体力 (Max Stamina)** | 48点 | 角色的体力上限，每30分钟消耗1点，0时技能效果-50% |
| **初始体力 (Initial Stamina)** | 48点 | 角色首次被创建/解锁并加入玩家列表时的初始体力，用于初始化 currentStamina，默认等于最大体力 |
| **攻击力 (Attack)** | 1点 | 优先攻击怪物 |
| **背包格子数量 (Inventory Slots)** | 待配置 | 角色背包可用格子总数。背包采用“格子+堆叠”模式：一种道具/资源在未超过该物品单格堆叠上限前，只占用1格；只有当该格的堆叠数量达到配置的最大堆叠数量后，新增同类物品才会占用新的格子。 |

### 6.2 角色状态
- **正常 (Normal)**: 血量 > 0
- **治疗中 (Healing)**: 正在使用医疗包进行治疗，每回合恢复1点生命值（详见8.4医疗包治疗机制）
- **死亡 (Dead)**: 血量 = 0 且未在治疗中
- **疲劳 (Exhausted)**: 体力 = 0

<!-- 濒死状态功能暂时关闭，保留设计以备后续使用
- **濒死 (Dying)**: 血量 = 0，回合结束前可治疗
-->

### 6.3 天赋系统
- **定义**: 角色初始拥有的技能或Buff
- **升级方式**: 消耗专属道具
- **配置方式**: 配置表设置
- **效果类型**: 
  - 被动技能
  - 属性加成
  - 特殊能力

### 6.4 科技树系统

#### 5.4.1 科技树分支
1. **体魄 (Physique)**
   - 增加战斗力
   - 增加背包容量
   - 增加耐力/体力上限
   - 增加血量上限

2. **智力 (Intelligence)**
   - 增加资源搜集种类
   - 增加收集数量
   - 解锁高级资源采集
   - 提升资源识别能力

3. **谋略 (Strategy)**
   - 增加探索效率
   - 解锁特殊能力
   - 提升战斗策略
   - 增加探索发现概率

#### 5.4.2 科技树解锁方式
- **方式1**: 消耗"科技点"主动选择
- **方式2**: 消耗专属道具定向解锁
- **配置**: 每个角色有专属科技树配置

### 6.5 末日前身份标签
- **作用**: 角色专属科技树的概括
- **影响**: 决定初始天赋和初始解锁的科技项
- **配置**: 配置表设置

### 6.6 探险者数据结构
```csharp
Explorer {
    string id;                   // 角色ID
    string name;                 // 角色名称
    string preApocalypseIdentity; // 末日前身份标签
    
    // 基础属性
    int maxHP;                   // 最大血量
    int currentHP;               // 当前血量
    int maxStamina;              // 最大体力
    int currentStamina;          // 当前体力
    int initialHP;               // 初始血量：角色首次创建/解锁并加入玩家列表时，用于赋值 currentHP，默认 = maxHP
    int initialStamina;          // 初始体力：角色首次创建/解锁并加入玩家列表时，用于赋值 currentStamina，默认 = maxStamina
    int attack;                  // 攻击力
    int inventoryCapacity;       // 背包格子数量（可用格子总数，采用格子+堆叠模式）
    
    // 系统
    List<Talent> talents;        // 天赋列表
    TechTree techTree;           // 科技树
    List<Item> inventory;        // 背包物品
    
    // 状态
    ExplorerStatus status;       // 角色状态
    bool isUnlocked;            // 是否解锁（测试阶段默认全部解锁）
}
```

> 所有探险者的初始数值（最大/初始血量与体力、攻击力等），必须通过角色配置表 ExplorerConfig 加载，不允许在代码中硬编码具体数值。

---

## 7. 勘探船系统设计

### 7.1 勘探船核心概念
- **勘探船与队伍分离**: 勘探船移动和队伍创建是分离的两个阶段
  - **移动阶段**: 在大地图上点击探索点，勘探船直接移动到目标探索点（无需预先选择队伍成员）
  - **队伍创建阶段**: 到达探索点后，才创建队伍选择进入探索点的角色和工具
- **队伍组成规则**: 
  - **最大人数**: 3人
  - **选择时机**: 到达探索点后，进入探索点前选择成员
  - **工具选择**: 同时选择每个角色使用的工具（装备、道具等）
  - **成员锁定**: 进入探索点后，队伍成员和工具固定不可更换，直到退出探索点
- **移动方式**: 勘探船作为整体在地图上移动，移动时无需选择队伍成员

### 7.2 勘探船状态与位置规则
- **勘探船状态**: 
  - 停靠中（可进行功能解锁等操作，此时无队伍概念）
  - 移动中（正在前往目标探索点的移动过程中，此时无队伍概念）
  - 到达探索点（已到达探索点，可创建队伍选择角色和工具）
  - 探索中（已创建队伍并进入探索点内部，正在挖矿和战斗，队伍成员和工具已锁定）
  - 返回中（正在返回停靠点的移动过程中，队伍已解散）
- **位置持久化规则**: 
  - **位置保持**: 勘探船在大地图上的位置在整个探索过程中持续保持，不会因为进入/退出探索点而重置
  - **从当前位置出发**: 当勘探船已在大地图上时（非在停靠点），选择新目标点后从当前位置出发，而非从停靠点出发
  - **时间连续**: 勘探船在地图上移动、进入探索点、退出探索点的过程中，回合数（时间）连续累计，不会重置
  - **成员锁定**: 勘探船在外探索时，成员固定不可更换，直到返回停靠点
- **当前位置交互**: 
  - **在大地图上点击探索点**: 直接移动勘探船到目标探索点（无需预先选择队伍）
  - **到达探索点后**: 弹出队伍创建界面，选择进入探索点的角色和工具
  - **勘探船位于某探索点时**: 点击该探索点可重新创建队伍进入探索（可更换角色和工具）
  - **勘探船位于大地图时**: 点击其他探索点会直接开始移动，无需确认队伍

### 7.3 勘探船数据结构
```csharp
ProspectingShip {
    Vector2Int currentPosition;   // 当前位置（勘探船位置）
    Vector2Int targetPosition;    // 目标位置
    ShipStatus status;            // 勘探船状态：停靠中/移动中/到达探索点/探索中/返回中
    int currentRound;             // 当前回合数
    Map<string, int> shipWarehouse; // 勘探船仓库资源（资源ID -> 数量）
    // 注意：队伍成员不存储在勘探船中，仅在进入探索点时临时创建
}

ExpeditionTeam {
    List<Explorer> members;      // 成员列表（最多3人），按选择顺序排序
    Map<string, Item> memberTools; // 成员使用的工具（角色ID -> 工具物品），在创建队伍时选择
    string explorationPointId;   // 当前探索的探索点ID
    bool isLocked;               // 队伍是否已锁定（进入探索点后锁定，退出后解散）
}
```

> 注意：每个角色的背包是独立的，存储在 `Explorer.inventory` 中，主要用于存储装备、特殊道具等非矿物物品。矿物资源直接存储在勘探船仓库（`ProspectingShip.shipWarehouse`）中，不占用角色背包空间。

### 7.4 背包使用规则
- **背包独立性**: 队伍中每个角色的背包独立，互不共享
- **背包容量判定**: 每个角色有固定的背包格子数量 `inventoryCapacity`（从 `ExplorerConfig` 加载）。当该角色背包中已有的“占用格子数” < `inventoryCapacity` 时，仍视为有空格；当占用格子数 ≥ `inventoryCapacity` 时，视为背包已满。
- **物品堆叠规则**: 
  - 每个物品/资源都有"堆叠最大数量"属性（在 `ItemConfig` 中配置）
  - 背包中1个格子最多可以堆叠该物品的堆叠最大数量
  - 超过堆叠最大数量的部分必须存放在新的格子上
  - 如果所有角色背包都没有空格子，则放入本回合的"临时背包"中
- **资源分配规则**: 
  - 当挖矿获得矿物资源时，直接放入勘探船仓库（`ProspectingShip.shipWarehouse`）
  - 矿物资源不再放入角色背包，无需考虑角色背包容量限制
  - 医疗包等特殊资源仍按原规则处理（医疗包存储在勘探船的 `medicalKits` 字段中）
- **临时背包规则**（已废弃）: 
  - 由于矿物资源直接放入勘探船仓库，不再需要临时背包机制
  - 临时背包相关字段和逻辑可以保留用于其他非矿物道具（如装备、特殊物品等），但矿物资源不占用临时背包
- **资源移动规则**: 
  - 矿物资源已直接存储在勘探船仓库中，无需在角色背包间移动
  - 玩家可以在探索过程中手动调整角色背包中非矿物物品（如装备、特殊道具）的存放位置
  - 可以在不同角色之间移动非矿物物品（前提是目标角色背包有空间）
  - 如果临时背包已解锁，可以在角色背包和临时背包之间移动非矿物物品
  - 资源移动操作不消耗回合或体力
- **物品丢弃规则**: 
  - 玩家可以整体丢弃背包中的物品（包括堆叠的物品，丢弃时整个格子清空）
  - 丢弃操作不消耗回合或体力
  - 丢弃的物品将永久消失，无法恢复
  - 建议在丢弃操作时提供二次确认，避免误操作
- **物品拆分规则**（低优先级功能）: 
  - 玩家可以将背包中堆叠的物品拆分为指定数量
  - 拆分后的物品需要放到一个空格子上（目标格子必须为空）
  - 拆分操作不消耗回合或体力
  - 拆分数量不能超过原格子的堆叠数量，也不能超过该物品的堆叠最大数量

---

## 8. 探索系统设计

### 8.1 探索流程
```
在大地图上点击探索点
    ↓
勘探船直接移动到目标探索点（每回合移动1格）
    ↓
到达探索点
    ↓
弹出队伍创建界面
    ├─ 选择进入探索点的角色（至少1人，最多3人）
    └─ 选择每个角色使用的工具（装备、道具等）
    ↓
确认创建队伍
    ↓
进入第1层探索棋盘（6x4格子）
    ↓
刷新角色、虫族、矿物
    ↓
进行探索操作（移动、挖矿、战斗）
    ↓
完成当前层探索（只要还有至少1个角色存活即可判定完成，或玩家主动退出）
    ↓
判断是否达到最大层数
    ├─ 未达到：进入下一层（层数+1），重新生成探索棋盘
    └─ 已达到：强制结束探索，返回地图界面，队伍解散，玩家可重新选择目标点
    ↓
（如果未达到最大层数）继续下一层探索
    ↓
（如果达到最大层数）退出探索点，队伍解散，返回大地图
    ↓
（可选）玩家可在任意时刻选择"退出"退出探索点，队伍解散，返回大地图（详见8.6退出探索点机制）
```

### 8.2 探索棋盘生成
- **棋盘大小**: 6格宽 × 4格高（24个格子）
- **层数机制**: 
  - 每个探索点配置有最大层数（`maxLayers`），在 `ExplorationPointConfig` 中独立配置
  - 每次进入探索点时，从第1层开始
  - 每探索完当前层（满足 8.3 的探索完成条件）后，自动进入下一层（层数+1），并重新生成新的探索棋盘
  - 达到最大层数后，强制结束该探索点的探索，返回地图界面，队伍解散，玩家可重新选择目标点
- **生成顺序**: 
  1. **角色放置**：从当前队伍成员中筛选出仍然存活的角色，将其随机放置在探索棋盘上允许的角色起始区域（例如上方若干行，具体由配置决定）；若存活角色少于起始格数量，剩余起始格保持为空
  2. **棋盘内容放置（虫族与矿物）**：在角色放置完成后，对棋盘上剩余的空格子按照格子编号由小到大遍历：
     - 从 `ExplorationPointConfig` 中读取该探索点的"棋盘出现内容"配置字段，该字段包含若干条以竖线 `|` 分隔的配置项，每项格式为：`出现类型_具体ID_出现权重值`，例如：`Monster_monster_bug_10|Garbage_mineral_ore_5`
     - 将每一条配置项视为一个候选单位，根据其"出现权重值"进行加权随机筛选，决定当前格子生成哪一种单位（如虫族 / 矿物 / 留空）
     - 当"出现类型"为 `Monster` 时，以 `具体ID` 在 `MonsterConfig` 中查找并生成虫族实例；当"出现类型"为 `Garbage` 时，以 `具体ID` 在 `ResourceConfig` 中查找并生成矿物（可挖矿资源）实例；若后续扩展其他类型（如陷阱等），按同样方式处理

> 探索棋盘中虫族与矿物的生成规则（种类、数量、概率等），完全由配置表（如 ExplorationPointConfig 的"棋盘出现内容"、MonsterConfig、ResourceConfig 等）驱动，代码只根据配置 ID 和权重规则进行计算，不直接写死具体组合。

### 8.3 探索棋盘规则
- **空间结构**: 探索棋盘为6格宽 × 4格高（共24个格子）
- **格子编号规则**: 
  - 格子编号从左上角第1个格子开始作为编号1，先向右编号（1, 2, 3, 4, 5, 6），再向下到下一行继续编号（7, 8, 9, 10, 11, 12），以此类推直到最右下方的格子编号为24
  - 编号公式：`格子编号 = (行号 - 1) × 6 + 列号`（行号和列号从1开始）
  - 格子编号用于战斗系统的攻击顺序判定（详见8.1战斗规则）
- **角色占用**: 每个角色占用1个格子
- **虫族生成**: 根据配置表设定的虫族类型和数量
- **矿物生成**: 原始矿物资源，需要通过角色特长天赋挖矿
- **基础产出**: 矿物有默认基础产出
- **产出提升**: 通过角色技能、天赋、科技树提升
- **回合与体力规则**: 
  - 探索棋盘内不再进行大地图移动
  - 每进入探索点的1层探索棋盘，视为“探索1层”，消耗1个回合（30分钟），体力-1（由3.1回合运作流程统一结算）
  - 同一层内的棋盘行动（移动、采集、战斗）发生在同一回合内，不额外推进回合计数
- **探索进度规则**: 
  - 对于每个探索点，对应地图格子的 `explorationProgress` 由当前层数和最大层数计算：`explorationProgress = currentLayer / maxLayers * 100`（四舍五入）
  - 当 `currentLayer >= maxLayers` 时，探索进度视为100%，满足4.2中“探索进度达到100%”的条件，可将探索点转换为空地
- **矿物产出处理规则**: 
  - **自动处理机制**：矿物产出不再需要玩家手动点击挖矿，而是在战斗结束后自动处理
  - **处理顺序**：战斗结算完成后，按棋盘编号从小到大遍历所有有矿物的格子，依次处理每个矿物的产出
  - **产出判定流程**：
    1. 对每个矿物格子，首先尝试触发"进阶产出机制"（检查 `GarbageConfig.进阶产出机制ID列表` 中配置的条件是否满足）
    2. 如果任一进阶产出机制条件满足，则使用 `GarbageConfig.进阶产出` 作为最终产出
    3. 如果所有进阶产出机制条件都不满足，则使用 `GarbageConfig.默认搜索产出` 作为最终产出
  - **产出应用**：所有矿物的产出直接自动添加到勘探船仓库（`ProspectingShip.shipWarehouse`）中，无需放入角色背包
  - **医疗包产出**：如果产出中包含医疗包，医疗包直接添加到勘探船的 `medicalKits` 字段中，不占用仓库空间
  - **负值产出处理**：当产出数量为负值时（如 `resource_food_-1`），从勘探船仓库中减少对应资源；如果仓库中没有该资源或数量不足，则不减少（不会扣到负数）
- **探索完成条件**: 
  - 只要队伍中还有至少1个角色存活（`currentHP > 0` 或正在治疗中），即判定完成了本层的探索，可以进入下一层
  - 玩家也可以主动选择退出当前层（返回地图界面）
  - 如果所有角色都死亡（血量 = 0 且未在治疗中），则探索失败，强制返回地图界面
- **层数规则**: 
  - 每次进入探索点均从第1层开始
  - 完成当前层探索后自动进入下一层（层数+1，重新生成探索空间）
  - 达到配置的最大层数后，强制结束探索并返回地图界面
  - 玩家需手动选择下一个目标点继续探索
- **棋盘刷新规则**: 
  - **每次进入新的一层探索棋盘时，必须对所有单位进行随机位置刷新**：
    - 角色位置：从当前存活的队伍成员中，随机选择不重复的格子进行放置
    - 虫族位置：根据"棋盘出现内容"配置，按权重随机生成虫族并随机放置在剩余空格子上
    - 矿物位置：根据"棋盘出现内容"配置，按权重随机生成矿物并随机放置在剩余空格子上
  - 同一探索点的不同层之间，角色、虫族、矿物的位置必须完全重新随机化，不能保留上一层的位置
  - 随机化算法应确保每次生成都有不同的布局，提升探索的多样性

### 7.4 探索数据结构
```csharp
ExplorationSpace {
    int width;                    // 宽度（6格）
    int height;                   // 高度（4格）
    GridCell[,] cells;            // 格子数组
    ExpeditionTeam currentTeam;   // 当前探索队伍（包含成员和工具）
    List<Monster> monsters;       // 虫族列表
    List<Mineral> minerals;       // 矿物列表
    ExplorationState state;       // 探索状态
    int currentLayer;            // 当前层数（从1开始）
    int maxLayers;                // 最大层数（从 ExplorationPointConfig 加载）
    string explorationPointId;    // 当前探索点ID
}
```

### 8.6 退出探索点机制
- **退出触发**: 玩家可在探索点内任意时刻选择"退出"或"撤退"（无论是在探索棋盘内还是在大地图上）
- **退出流程**: 
  - 点击退出后，队伍自动解散
  - 角色和工具返回（工具返回勘探船仓库或角色背包）
  - 返回大地图界面，勘探船位于该探索点位置
- **退出后状态**: 
  - 勘探船状态变为"到达探索点"（可重新创建队伍进入探索）
  - 矿物资源已在探索过程中直接存储在勘探船仓库中，无需额外保存操作
  - 所有停靠点的仓库共享（共享仓库系统），玩家可以随时查看和使用仓库中的资源
- **重新进入**: 
  - 退出探索点后，可以重新创建队伍进入探索
  - 可以更换角色和工具

---

## 9. 战斗系统设计

### 8.1 战斗规则
- **战斗类型**: 战斗是回合内处理计算的类型，每个回合在满足触发条件时进行一次完整的战斗运算
- **战斗触发**: 
  - 探索棋盘内：当角色攻击范围内有虫族时触发战斗
    - **攻击范围定义**：角色的攻击范围默认为相邻格子（包括上下左右4个方向以及斜方向的左上、左下、右上、右下，总共8个方向，距离1格），可通过角色属性或科技树扩展
    - 每个回合开始时，系统检测所有角色的攻击范围内是否有虫族，如果有则触发战斗；战斗结算完成后，玩家再进行本回合内的其它棋盘行动
  - 返回路径：在深夜时大概率遇到虫族（大地图上的战斗）
- **探索棋盘格子编号规则**: 
  - 探索棋盘为6格宽 × 4格高（共24个格子）
  - 格子编号从左上角第1个格子开始作为编号1，先向右编号（1, 2, 3, 4, 5, 6），再向下到下一行继续编号（7, 8, 9, 10, 11, 12），以此类推直到最右下方的格子编号为24
  - 编号公式：`格子编号 = (行号 - 1) × 6 + 列号`（行号和列号从1开始）
- **攻击顺序与目标规则**: 
  - **第一阶段（角色攻击阶段）**：先由我方角色按照所在格子的编号由小到大的顺序进行攻击
    - 对于每个角色，按照其攻击范围内所有敌人的格子编号由小到大依次结算攻击，默认不限制本次攻击涉及的敌人数量（即可依次攻击范围内所有敌人）
  - **第二阶段（虫族攻击阶段）**：再由虫族按照所在格子的编号由小到大的顺序进行攻击
    - 对于每个虫族，按照其攻击范围内所有角色的格子编号由小到大依次结算攻击，同样默认不限制目标数量
  - 如果同一格子内有多个角色或多个虫族，则在该格内按加入战斗的顺序或ID排序
- **伤害计算**: 攻击力直接扣除血量（后续如引入防御等机制，再在此扩展）
- **先手规则**: 角色优先攻击虫族（角色攻击阶段在虫族攻击阶段之前）

### 8.2 战斗流程
```
检测战斗触发条件（角色攻击范围内是否有虫族）
    ↓
触发战斗（回合内战斗计算开始）
    ↓
第一阶段：角色攻击阶段
    ├─ 按探索棋盘格子编号由小到大遍历
    ├─ 对每个格子中的角色，依次对其攻击范围内所有敌人（按格子编号由小到大排序）进行攻击
    └─ 如果虫族死亡，从战斗列表中移除
    ↓
第二阶段：虫族攻击阶段
    ├─ 按探索棋盘格子编号由小到大遍历
    ├─ 对每个格子中的虫族，依次对其攻击范围内所有角色（按格子编号由小到大排序）进行攻击
    └─ 如果角色血量降至0，角色进入死亡状态（除非正在治疗中）
    ↓
判断战斗结果
    ├─ 如果所有虫族死亡：角色胜利，获得战利品，继续在本层探索棋盘中行动
    ├─ 如果所有角色死亡：探索失败，强制返回地图界面
    └─ 如果双方都有存活单位：本回合战斗计算结束，下一回合开始时如仍满足触发条件，将再次进行战斗计算
    ↓
战斗后矿物产出处理（详见8.3战斗后矿物产出规则）
    ↓
战斗结束（本回合战斗计算完成）
```

### 8.3 战斗后矿物产出规则
- **触发时机**：每个回合战斗结算完成后，自动触发矿物产出处理
- **处理顺序**：按棋盘编号从小到大遍历所有有矿物的格子（`ExplorationBoardCell.garbageId` 不为空的格子）
- **产出判定**：对每个矿物格子：
  1. 读取该矿物的配置（`GarbageConfig`）
  2. 检查是否满足"进阶产出机制"条件（详见9.2资源挖矿规则中的进阶产出机制）
  3. 如果满足任一进阶产出机制，使用 `GarbageConfig.进阶产出` 作为产出
  4. 如果不满足，使用 `GarbageConfig.默认搜索产出` 作为产出
- **产出应用**：
  - 所有矿物的产出自动合并后，直接添加到勘探船仓库（`ProspectingShip.shipWarehouse`）中
  - 矿物资源不再放入角色背包，直接存储在勘探船仓库中
  - 支持负值产出：当产出数量为负值时（如 `resource_food_-1`），从勘探船仓库中减少对应资源
  - 负值处理规则：如果仓库中没有该资源或数量不足，则不减少（不会扣到负数）
- **玩家操作**：矿物产出处理完全自动化，玩家无需手动点击挖矿按钮

### 8.4 医疗包治疗机制

#### 8.4.1 医疗包系统概述
医疗包是独立的资源类型，不占用角色背包空间，也不占用勘探船仓库空间。每次勘探船出发探索时携带的医疗包数量有上限限制。医疗包可以在探索棋盘中收集，也可以从勘探船仓库带出。

#### 8.4.2 医疗包获取
- **从勘探船仓库带出**: 在勘探船界面（停靠时），玩家可以选择携带一定数量的医疗包（不超过携带上限）
- **探索棋盘收集**: 医疗包可以在探索棋盘中作为矿物产出收集到，与从勘探船仓库带出的医疗包存放在同一个存储位置中
- **医疗包存储**: 医疗包存储在勘探船的 `medicalKits` 字段中，不占用角色背包，也不占用仓库空间

#### 8.4.3 医疗包使用
- **使用时机**: 玩家可以在探索棋盘中随时使用医疗包
- **使用方式**: 点击医疗包，选择要治疗的目标角色
- **治疗效果**: 
  - 被治疗的角色将在接下来的3个回合中，每个回合恢复1点生命值
  - 治疗期间，被治疗的角色无法触发探索技能（如采集、特殊能力等）
  - 治疗期间，被治疗的角色可以正常参与战斗
- **治疗状态**: 角色进入"治疗中"状态，持续3个回合

#### 8.4.4 治疗状态管理
- **治疗回合计数**: 每个被治疗的角色需要记录剩余治疗回合数
- **回合推进**: 每回合开始时，检查所有治疗中的角色，减少剩余治疗回合数，并恢复1点生命值
- **治疗完成**: 当剩余治疗回合数为0时，角色退出"治疗中"状态
- **治疗中断**: 如果角色在治疗期间再次受到伤害，治疗状态不会中断，继续按回合恢复生命值

#### 8.4.5 医疗包数据结构
```csharp
// 伪代码结构
HealingStatus {
    string explorerId;        // 被治疗的角色ID
    int remainingRounds;      // 剩余治疗回合数（初始为3）
    int startRound;           // 开始治疗的回合数
}

ExpeditionTeam {
    // ... 其他字段 ...
    int medicalKits;          // 当前医疗包数量
    int maxMedicalKits;       // 医疗包携带上限
    List<HealingStatus> healingStatuses; // 当前治疗中的角色列表
}
```

#### 8.4.6 医疗包配置
- **携带上限**: 在配置表中定义每次探索可以携带的医疗包数量上限（建议初始值为3-5个）
- **医疗包ID**: 医疗包作为特殊资源类型，在 `ResourceConfig` 中配置，标记为"医疗包"类型
- **产出配置**: 在 `GarbageConfig`（或 `MineralConfig`）中可以配置医疗包作为矿物产出

<!-- 濒死处理功能暂时关闭，保留设计以备后续使用
### 8.4 濒死处理（已废弃）
- **触发条件**: 角色血量 = 0
- **处理时间**: 回合结束前
- **恢复方式**: 消耗背包中的补血道具
- **失败后果**: 回合结束时未治疗则角色死亡
-->

### 8.5 角色死亡处理
- **触发条件**: 角色血量 = 0 且未在治疗中
- **死亡位置**: 角色死亡时所在的格子（探索空间内或地图上）
- **数据存储**: 
  - 角色死亡时，将该角色背包中的所有物品转移到死亡格子的 `GridCell.droppedItems` 字段中
  - 记录死亡时的回合数到 `GridCell.deathRound` 字段
  - 记录死亡角色的ID到 `GridCell.deadExplorerId` 字段
- **背包物品处理**: 
  - 死亡的该角色的背包中的物品将落在死亡的格子上（存储在 `GridCell.droppedItems` 中）
  - 玩家在96个回合内还能查看和拿走背包中的物品（96回合 = 48小时 = 2天游戏时间）
  - **过期判断**：从角色死亡时的回合数开始计算，无论队伍是否在场。当 `当前回合数 - GridCell.deathRound >= 96` 时，该格子的 `droppedItems` 将被清空（物品消失）
  - 其他角色（包括同队伍成员或其他探险队）可以前往死亡格子拾取物品
- **物品拾取规则**: 
  - 队伍需要移动到死亡格子才能拾取物品
  - 拾取时打开物品列表界面（显示 `GridCell.droppedItems`），玩家可选择拾取哪些物品
  - 拾取的物品如果是矿物资源，直接放入勘探船仓库
  - 拾取的物品如果是非矿物物品（如装备、特殊道具），按照6.4资源移动规则放入角色背包
  - 如果角色背包已满，放入临时背包（临时背包会自动解锁）
- **资源处理**: 
  - 角色死亡时该角色背包内的非矿物物品（如装备、特殊道具）将全部保留（保留在死亡格子上，遵循96回合规则）
  - 矿物资源不受影响，因为已直接存储在勘探船仓库中
  - 非矿物物品拾取规则与物品相同，可在96回合内由其他角色拾取
- **角色损失**: 
  - 角色的其他部分（角色本身、天赋、科技树进度等）将彻底损失
  - 角色从玩家列表中移除（或标记为已死亡）
  - 角色无法复活，需要重新解锁或获取

---

## 10. 资源系统设计

### 9.1 资源类型
- **基础资源**: 食物、水、材料等
- **特殊资源**: 科技点、专属道具等
- **矿物资源**: 探索棋盘中的原始矿物
- **医疗包**: 独立的资源类型，不占用背包空间，用于治疗角色（详见8.4医疗包治疗机制）

### 9.2 资源挖矿规则
- **基础产出**: 矿物有默认基础产出
- **产出提升**: 
  - 角色天赋加成
  - 科技树加成
  - 技能效果
- **体力影响**: 体力为0时，只能获得基础产出
- **资源分配**: 
  - 挖矿获得的矿物资源直接放入勘探船仓库（`ProspectingShip.shipWarehouse`）
  - 矿物资源不再放入角色背包，无需考虑角色背包容量限制
  - 玩家无需手动管理矿物资源在角色背包间的分配
- **仓库存储**: 
  - 勘探船仓库使用 `Map<string, int>` 结构存储资源（资源ID -> 数量）
  - 相同资源ID的资源自动累加数量，无堆叠限制
  - 仓库容量理论上无上限（可根据游戏平衡性设置上限）
- **负值产出处理**: 
  - 当矿物的默认产出或进阶产出中包含负值数量时（如 `resource_food_-1`），系统会从勘探船仓库中减少对应资源
  - 减少规则：从仓库中直接减少对应数量，如果数量不足则只减少到0（不会扣到负数）
  - 如果仓库中完全没有该资源，则不进行任何操作（不减少）

### 9.3 资源保存
- **保存机制**: 矿物资源在挖矿时直接自动保存到勘探船仓库，无需额外保存操作
- **仓库系统**: 所有停靠点的仓库共享（共享仓库系统），无论勘探船在哪个停靠点，资源都保存在同一个仓库中
- **实时存储**: 
  - 矿物资源在战斗后矿物产出处理时直接添加到勘探船仓库
  - 玩家可以随时查看勘探船仓库中的资源数量
  - 无需等待返回停靠点，资源已实时存储在仓库中
- **角色背包用途**: 
  - 角色背包现在主要用于存储装备、特殊道具等非矿物物品
  - 矿物资源不再占用角色背包空间
- **角色死亡情况**: 角色死亡时，如果角色背包中有非矿物物品（如装备），这些物品将落在死亡格子上，遵循96回合拾取规则（详见8.5角色死亡处理）。矿物资源不受影响，因为已直接存储在勘探船仓库中

### 9.4 资源使用
- **章节功能解锁**: 消耗资源解锁不同章节的功能（详见10.4功能解锁流程）
- **角色强化**: 通过勘探船功能解锁后，消耗特定道具对单个角色的属性或技能效果进行一次性提升（如最大体力上限+2）
- **科技树解锁**: 通过勘探船功能解锁后，消耗科技点或专属道具解锁科技树节点
- **天赋升级**: 通过勘探船功能解锁后，消耗专属道具升级角色天赋
- **装备制作**: 通过勘探船功能解锁后，消耗资源制作装备

> 注意：角色强化、科技树解锁、天赋升级等功能需要先在勘探船中解锁对应的功能模块，才能使用。

---

## 11. 勘探船系统设计

### 10.1 勘探船系统概述

勘探船系统是游戏的核心系统之一，与任务系统和章节系统紧密配合，用于推进主线剧情。勘探船既是移动基地，也是探险小队本身，随章节变化而变更形态和功能。

**核心设计理念**：
- **移动基地**: 勘探船随章节推进而移动，每个章节对应不同的勘探船形态和功能
- **船队合一**: 勘探船就是探险小队，两者概念合并。勘探船移动即代表探险小队移动
- **任务驱动**: 勘探船功能解锁与任务系统挂钩，通过完成任务推进主线
- **资源消耗**: 解锁章节功能需要消耗资源，形成资源挖矿→功能解锁→推进主线的循环

### 10.2 勘探船功能

#### 10.2.1 基础功能（所有章节通用）
- **角色管理**: 在停靠时选择探险者组成队伍（固定在勘探船上）
- **资源存储**: 保存挖矿获得的资源到勘探船仓库
- **停靠点**: 勘探船可以返回停靠点进行休整和功能操作

#### 10.2.2 章节功能（按章节解锁）
每个章节可以解锁不同的功能模块，功能解锁通过消耗资源实现。功能解锁后，玩家可以在该章节及后续章节中使用这些功能。

**功能类型示例**：
- **角色强化功能**: 消耗资源对角色进行一次性强化（如提升最大体力上限）
- **装备制作功能**: 消耗资源制作装备
- **科技研究功能**: 消耗资源解锁科技树节点
- **天赋升级功能**: 消耗资源升级角色天赋
- **特殊功能**: 章节专属的特殊功能（如传送、快速移动等）

### 10.3 勘探船与章节的关系

#### 10.3.1 移动基地机制
- **章节切换**: 当玩家完成章节结束任务，解锁新章节时，勘探船会移动到新章节对应的位置
- **形态变化**: 不同章节的勘探船可能有不同的外观和功能列表
- **功能继承**: 已解锁的功能在后续章节中继续可用（除非特别说明）

#### 10.3.2 章节功能配置
每个章节在 `ChapterConfig` 中配置该章节可解锁的功能列表：
- **功能ID**: 唯一标识一个功能
- **功能名称**: 多语言Key
- **功能描述**: 多语言Key
- **解锁条件**: 消耗的资源列表（格式：`资源ID_数量|资源ID_数量`）
- **前置功能**: 需要先解锁的功能ID（可选）
- **功能类型**: 功能分类（如：角色强化、装备制作、科技研究等）

### 10.4 功能解锁流程

#### 10.4.1 解锁条件检查
1. **章节检查**: 玩家必须处于该功能所属的章节或后续章节
2. **前置功能检查**: 如果功能有前置功能，需要先解锁前置功能
3. **资源检查**: 检查勘探船仓库中是否有足够的资源
4. **停靠状态检查**: 勘探船必须处于停靠状态才能解锁功能

#### 10.4.2 解锁操作
1. 玩家在勘探船界面（停靠时）选择要解锁的功能
2. 系统检查解锁条件
3. 如果条件满足，弹出确认对话框，显示需要消耗的资源
4. 玩家确认后，从仓库中扣除资源
5. 功能解锁，玩家可以使用该功能

#### 10.4.3 解锁状态持久化
- 功能解锁状态需要保存到存档中
- 解锁状态在章节切换时保留
- 读档时恢复所有已解锁的功能状态

### 10.5 勘探船数据结构

```csharp
// 伪代码结构
ProspectingShip {
    string shipId;                  // 勘探船ID
    string contractId;              // 租用合同ID
    DifficultyLevel difficulty;     // 难度等级
    string currentChapterId;        // 当前所属章节ID
    List<string> unlockedFeatures;    // 已解锁的功能ID列表
    Map<string, int> warehouse;       // 仓库资源（资源ID -> 数量）
    ShipAppearance appearance;      // 当前勘探船外观（根据章节变化）
    List<Explorer> members;          // 成员列表（最多3人），固定在勘探船上
    Vector2Int currentPosition;      // 当前位置（勘探船位置）
    ShipStatus status;                // 勘探船状态：停靠中/移动中/探索中/返回中
    ContractRestrictions activeRestrictions; // 当前生效的合同限制条件
    ContractSpecialRules activeSpecialRules; // 当前生效的合同特殊规则
}

ShipFeature {
    string featureId;                // 功能ID
    string nameKey;                   // 功能名称（多语言Key）
    string descKey;                   // 功能描述（多语言Key）
    string chapterId;                 // 所属章节ID
    List<ResourceCost> unlockCost;    // 解锁消耗的资源列表
    List<string> prerequisiteFeatures; // 前置功能ID列表
    FeatureType type;                 // 功能类型
    FeatureStatus status;             // 功能状态：未解锁/已解锁
}

ResourceCost {
    string resourceId;                // 资源ID
    int quantity;                     // 数量
}

FeatureType {
    CharacterEnhancement,    // 角色强化
    EquipmentCrafting,        // 装备制作
    TechResearch,            // 科技研究
    TalentUpgrade,           // 天赋升级
    Special                  // 特殊功能
}

FeatureStatus {
    Locked,      // 未解锁
    Unlocked    // 已解锁
}
```

### 10.6 勘探船界面设计

#### 10.6.1 界面布局
- **功能列表区域**: 显示当前章节可解锁的功能列表
- **功能详情区域**: 显示选中功能的详细信息（描述、解锁条件、消耗资源）
- **仓库区域**: 显示当前勘探船仓库中的资源
- **解锁按钮**: 当满足解锁条件时，显示"解锁"按钮（仅在停靠状态可用）

#### 10.6.2 功能显示规则
- **已解锁功能**: 显示为已解锁状态，可以点击使用
- **可解锁功能**: 显示为可解锁状态（资源充足），显示"解锁"按钮
- **不可解锁功能**: 显示为锁定状态，显示缺少的资源或前置条件
- **未到达章节功能**: 不显示或显示为灰色（未到达该章节）

### 10.7 勘探船与任务系统的集成

#### 10.7.1 任务驱动解锁
- 某些关键功能可能需要完成特定任务后才能解锁（即使资源充足）
- 任务配置中可以指定"解锁功能ID"字段，完成任务后自动解锁功能

#### 10.7.2 功能解锁任务
- 可以创建专门的功能解锁任务
- 任务完成条件可以是"解锁指定功能"
- 完成任务后可以获得奖励，并解锁新功能

### 10.8 废弃的设计（已移除）

以下设计已废弃，不再使用：
- ❌ **建设系统**: 不再在地图上建设固定建筑
- ❌ **勘探船等级系统**: 不再使用等级系统，改为章节功能系统
- ❌ **设施管理**: 不再管理固定设施，改为功能解锁系统
- ❌ **ShelterLevelConfig**: 不再使用勘探船等级配置表（保留配置表结构，但语义改为勘探船相关）

### 10.9 配置表设计

#### 10.9.1 章节功能配置（在 ChapterConfig 中扩展）
在 `ChapterConfig` 中新增字段：
- **可解锁功能ID列表**: 该章节可解锁的功能ID列表（以 `|` 分隔）

#### 10.9.2 功能配置表 (ShipFeatureConfig)
新建功能配置表，字段定义：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| ID | string | 功能ID（唯一标识） | "feature_character_enhancement" |
| 名称Key | string | 功能名称的多语言Key | "feature.character.enhancement.name" |
| 描述Key | string | 功能描述的多语言Key | "feature.character.enhancement.desc" |
| 所属章节ID | string | 该功能所属的章节ID | "chapter_001" |
| 解锁消耗资源列表 | string | 解锁消耗的资源列表（格式：资源ID_数量\|资源ID_数量） | "resource_metal_10\|resource_food_5" |
| 前置功能ID列表 | string | 需要先解锁的功能ID列表（以\|分隔，可选） | "feature_basic_crafting" |
| 功能类型 | string | 功能类型 | "CharacterEnhancement" |
| 优先级 | number | 显示优先级（数字越小优先级越高） | 1 |

---

## 12. 配置表系统设计

在本项目中，地图（格子类型与分布）、探险者（属性与状态）、探索点（可生成的虫族与矿物）、勘探船功能解锁等**核心游戏数据全部采用配置驱动**的方式进行管理。  
代码负责解析和使用配置数据，但不直接硬编码具体数值、坐标或解锁关系。

### 11.1 配置表清单
1. **勘探船配置表 (ShipConfig)**
   - 勘探船ID (shipId)：唯一标识一艘勘探船
   - 名称Key (nameKey)：勘探船名称的多语言Key
   - 描述Key (descKey)：勘探船描述的多语言Key
   - 外观资源路径 (appearancePath)：勘探船外观资源的路径
   - 默认合同ID (defaultContractId)：该船对应的默认租用合同ID

2. **租用合同配置表 (ShipContractConfig)**
   - 合同ID (contractId)：唯一标识一个租用合同
   - 勘探船ID (shipId)：该合同对应的勘探船ID
   - 合同名称Key (nameKey)：合同名称的多语言Key
   - 合同描述Key (descKey)：合同描述的多语言Key
   - 难度等级 (difficulty)：简单/普通/困难 或 1-5星
   - 初始资源 (initialResources)：格式 `资源ID_数量|资源ID_数量`（可选）
   - 初始角色ID列表 (initialExplorerIds)：格式 `角色ID|角色ID`（可选）
   - 初始解锁功能ID列表 (initialUnlockedFeatures)：格式 `功能ID|功能ID`（可选）
   - 仓库容量上限 (maxWarehouseCapacity)：数字或空（表示无限制）
   - 最大角色数量 (maxExplorerCount)：数字或空（表示无限制）
   - 限制招募角色ID列表 (restrictedExplorerIds)：格式 `角色ID|角色ID`（可选）
   - 特殊规则类型 (specialRuleType)：字符串（如"doubleResource"、"hardMode"等，可选）
   - 特殊规则参数 (specialRuleParams)：JSON格式字符串（可选）

3. **角色配置表 (ExplorerConfig)**
   - 角色基础属性（最大/初始血量与体力、攻击力等）
   - 初始背包格子数量（inventoryCapacity，用于决定角色背包可用格子总数）
   - 初始天赋ID列表（initialTalentIds，对应 `TalentConfig.talentId`）
   - 初始科技树解锁项
   - 末日前身份标签

2. **科技树配置表 (TechTreeConfig)**
   - 科技项ID
   - 科技名称
   - 所属分支（体魄/智力/谋略）
   - 解锁条件
   - 效果描述

3. **怪物配置表 (MonsterConfig)**
   - 怪物ID
   - 怪物名称
   - 血量、攻击力
   - 出现时间段
   - 出现概率

4. **地图配置表 (MapConfig)**
   - 格子类型
   - 格子坐标
   - 初始状态
   - 资源生成规则

5. **探索点配置表 (ExplorationPointConfig)**
   - 探索点ID
   - **注意**：探索点的位置坐标不在此表配置，而是由 `MapConfig` 中格子类型为"探索点"的格子通过 `资源生成规则ID` 字段关联决定
   - 最大层数 (maxLayers)：该探索点一次进入可探索的最大层数，达到后强制结束探索
   - 探索难度
   - 棋盘出现内容：配置该探索点在探索棋盘上可出现的单位（虫族/矿物等）及其权重，格式为若干条 `出现类型_具体ID_出现权重值` 组成的列表（以竖线 `|` 分隔）

6. **资源配置表 (ResourceConfig)**
   - 资源ID
   - 资源名称
   - 基础产出
   - 稀有度
   - 堆叠最大数量 (maxStackSize)：该资源在背包中1个格子上最多可以堆叠的数量，超过此数量需占用新格子

7. **道具配置表 (ItemConfig)**
   - 道具ID
   - 道具名称
   - 道具类型
   - 使用效果
   - 堆叠最大数量 (maxStackSize)：该物品在背包中1个格子上最多可以堆叠的数量，超过此数量需占用新格子

8. **勘探船等级配置表 (ShipLevelConfig)**（可选，如保留等级系统）
   - 等级 (level)
   - 默认解锁设施列表 (autoUnlockedFacilities)：勘探船达到该等级时自动解锁/建成的设施 ID 列表
   - 可建造设施列表 (buildableFacilities)：从该等级开始允许建造的设施 ID/类型列表
   - （可选）最大设施数量 (maxFacilitySlots)
   - （可选）升级前置条件 (requirements)：升级到该等级所需资源或前置条件

9. **技能配置表 (SkillConfig)**
   - 技能ID (skillId)：唯一标识一个技能，同时作为代码侧技能效果注册表中的键值
   - 名称文本Key (nameKey)：用于前端显示技能名称
   - 描述文本Key (descKey)：用于前端显示技能描述，可在文案中使用 `{icon:图标ID}` 占位符插入图标
   - 效果类型 (effectType)：用于**归类**该技能的大致类型，例如 `BattleBuff`、`ExploreBuff`、`ExtraDrop` 等（便于策划筛选与检索）
   - 效果参数 (effectParams)：以字符串形式存储的参数，由代码解析，例如 `shieldRate=0.2;durationRounds=3` 或 JSON 字符串；
     - 代码侧会根据 `skillId` 在技能效果注册表中找到对应的处理函数，并将解析后的参数对象传入
    - 触发时机 (triggerTiming)：该技能效果被结算的时机，例如：`OnBattleStart`、`OnAttack`、`OnMineralMined`、`OnEnterExplorationBoard` 等
   - 作用目标 (targetType)：技能生效的目标范围，例如：`Self`（自身）、`CurrentExplorer`（当前执行动作的角色）、`Team`（当前小队全体）等
   - （可选）消耗道具ID (requiredItemId)：学习或激活该技能需要消耗的道具ID（对应 `ItemConfig`），用于实现“吞卡/消耗品解锁技能”等玩法

10. **天赋配置表 (TalentConfig)**
    - 天赋ID (talentId)：唯一标识一个天赋，同时作为代码侧天赋效果注册表中的键值
    - 名称文本Key (nameKey)：用于前端显示天赋名称
    - 描述文本Key (descKey)：用于前端显示天赋描述，可在文案中使用 `{icon:图标ID}` 占位符插入图标
    - 效果类型 (effectType)：用于归类该天赋的大致类型，例如 `PermanentBuff`、`BattleBuff`、`ExploreBuff` 等
    - 效果参数 (effectParams)：以字符串形式存储的参数，由代码解析并传入对应的天赋效果处理函数
    - 解锁条件类型 (unlockConditionType)：用于区分不同的解锁逻辑，例如 `TechReached`（达成某科技）、`ShipLevelReached`（勘探船等级达到X）、`StoryFlag`（剧情标记）等
    - 解锁条件参数 (unlockConditionParams)：以字符串形式存储的解锁条件参数，例如 `TechId=tech_engineer;Level>=2`
    - 是否可叠加 (stackable)：true/false，用于标记该天赋是否可以被多次获得并叠加效果
    - （可选）最大叠加层数 (maxStacks)：当 `stackable = true` 时，限制该天赋最多可叠加多少层（为空时视为无限）

11. **矿物配置表 (GarbageConfig 或 MineralConfig)**
    - 矿物ID (garbageId 或 mineralId)
    - 名称文本Key (nameKey)
    - 描述文本Key (descKey)：支持在文案中使用 `{icon:图标ID}` 形式的占位符插入图标，用于直观展示进阶产出机制
    - 默认挖矿产出 (defaultSearchOutput)：当该矿物被正常挖矿时的基础产出，格式为 `资源ID_数量` 列表，以竖线 `|` 分隔，例如 `resource_metal_1|resource_food_2`
    - 矿物类型列表 (garbageTypes 或 mineralTypes)：该矿物所属的类型标签列表，用于与角色技能触发条件匹配，多个类型以竖线 `|` 分隔，例如 `金属矿|能源矿`
    - 进阶产出机制ID列表 (advancedOutputConditionIds)：引用进阶产出机制配置表 `AdvancedOutputConditionConfig` 中的 conditionId，多个值以竖线 `|` 分隔
    - 进阶产出 (advancedOutput)：当满足任一进阶产出机制时，用于替代默认搜索产出的高级产出配置，格式同 `defaultSearchOutput`，例如 `resource_metal_5|resource_rare_chip_1`

12. **进阶产出机制配置表 (AdvancedOutputConditionConfig)**
    - 进阶产出机制ID (conditionId)
    - 名称文本Key (nameKey)
    - 描述文本Key (descKey)：用于向玩家解释该机制的触发条件与效果，同样支持 `{icon:图标ID}` 占位符
    - 适用矿物类型列表 (targetGarbageTypes 或 targetMineralTypes)：该机制适用的矿物类型标签列表，多个类型以竖线 `|` 分隔；当某个矿物的 `garbageTypes`（或 `mineralTypes`）与该列表有交集时，该机制有资格被应用
    - 触发条件类型 (conditionType)：用于代码区分不同类型的触发逻辑，如 `ExplorerTagCount`（需要特定标签的角色数量）、`Difficulty`（探索点难度）、`Mixed`（复杂组合）等
    - 触发条件参数 (conditionParams)：以字符串形式存储的条件参数（可采用简单的 `Key=Value;Key2=Value2` 形式或JSON字符串），由游戏逻辑解析和执行

### 11.2 配置表格式建议
- **格式**: JSON 或 ScriptableObject（Unity推荐）
- **位置**: `Assets/Config/`
- **加载方式**: 运行时加载或序列化

---

## 13. 系统架构设计

### 12.1 核心系统模块
```
GameManager (游戏管理器)
    ├── TimeSystem (时间系统)
    ├── RoundSystem (回合系统)
    ├── MapSystem (地图系统)
    ├── ExplorerSystem (探险者系统)
    ├── ExpeditionSystem (探险队系统)
    ├── ExplorationSystem (探索系统)
    ├── BattleSystem (战斗系统)
    ├── ResourceSystem (资源系统)
    ├── ShipSystem (勘探船系统)
    └── ConfigSystem (配置表系统)
```

### 12.2 数据层设计
- **GameData**: 游戏存档数据
- **ConfigData**: 配置表数据
- **RuntimeData**: 运行时临时数据

### 12.3 UI层设计
- **MainUI**: 主界面
- **MapUI**: 地图界面
- **ExplorerUI**: 探险者管理界面
- **ExpeditionUI**: 探险队界面
- **ExplorationUI**: 探索界面
- **BattleUI**: 战斗界面
- **ShipUI**: 勘探船界面
- **TechTreeUI**: 科技树界面
- **InventoryUI**: 背包界面
  - **功能入口**：在探索界面底部提供"背包"按钮，点击后打开背包面板
  - **显示内容**：显示当前探险队所有成员的背包状态
  - **信息展示**：每个队员显示头像、名称、HP状态、背包格子列表
  - **格子显示**：每个背包格子显示物品图标、名称、数量；空格子显示为空
  - **交互方式**：背包界面为只读查看模式（当前版本），玩家可查看但不能直接操作（物品移动等功能待后续实现）

#### 12.3.1 输入与交互规范
- **输入设备**  
  - Demo 阶段主要支持键鼠操作（鼠标点击/拖拽 + 键盘快捷键）；手柄和触摸支持可在后续版本扩展。
- **基础交互规则**  
  - 所有可点击 UI 元素必须具备 Hover（悬停）与 Pressed（按下）两种视觉反馈状态。  
  - 所有关键破坏性操作（例如删除存档、退出到主菜单、放弃当前探索）必须有二次确认对话框。  
  - 统一的返回/取消逻辑：ESC 键或右键点击应尽可能返回上一级界面或关闭当前弹窗。
- **布局与分层**  
  - UI 需根据场景分层管理（主界面层、地图层、战斗层、弹窗层等），避免互相遮挡和输入冲突。

#### 12.3.2 分辨率与适配
- **分辨率要求**  
  - 推荐分辨率：1920×1080（16:9），其他宽高比需要保证 UI 不错位、不裁切。  
  - 最低支持分辨率由美术与技术共同评估后在实现阶段细化。
- **字体与可读性**  
  - 重要文本（数值、按钮文字）需保证在最低分辨率下仍具备可读性，不允许过小字体。  
  - 文本长度变化（特别是未来多语言）不应导致布局破坏，应预留足够容错空间。

### 12.4 性能与规模边界

- **地图与探索棋盘规模**  
  - 地图尺寸上限建议控制在 100×100 格以内，以便保证性能和内容生产成本。  
  - 单个探索棋盘固定为 6×4（24 个格子），后续如需扩展需重新评估性能与可玩性。
- **单位数量上限（Demo 阶段）**  
  - 单个探索空间内的虫族数量、矿物数量、资源堆数量应设定合理上限（例如：虫族不超过 10 个，矿物不超过 20 堆），具体数值由配置表与实际性能测试共同确定。  
  - 同一时刻仅允许一支探险队在外探索（单队伍模式），以降低系统复杂度。
- **性能目标（PC Demo）**  
  - 目标平台为 PC，窗口/全屏模式下期望维持 60 FPS。  
  - 在“推荐规模”（例如 50×50 地图 + 若干探索点 + 一支满员队伍）下，帧率不应出现明显跌落。
- **优化优先级**  
  - 地图加载与寻路逻辑优先保证性能；  
  - 探索空间更新（包括怪物 AI 与碰撞检测）其次；  
  - UI 更新与特效需要在不影响主循环的前提下实现。

---

## 14. 数据持久化设计

### 13.1 存档数据结构
```csharp
SaveData {
    int version;                 // 存档版本号，用于兼容性判断和迁移
    string shipId;              // 选择的勘探船ID
    string contractId;            // 选择的租用合同ID
    int currentDay;              // 当前天数
    int currentRound;            // 当前回合数
    List<ExplorerData> explorers; // 探险者数据
    MapData mapData;             // 地图数据
    ShipData shipData;           // 勘探船数据
    ResourceData resourceData;   // 资源数据
    ExpeditionData expeditionData; // 探险队数据
}
```

### 13.2 存档时机
- **自动存档**: 在每个回合完全结束，并完成所有结算（包括时间推进、体力扣除、临时背包清空等）后自动保存一次
- **手动存档**: 仅允许在回合结束状态（未开始下一回合前）触发，避免半回合状态存档
- **读取规则**: 重新读取存档时，总是从"新回合开始"的状态恢复，玩家只能继续点击"下一回合"推进游戏
- **合同恢复**: 读档时需要根据存档中的 `contractId` 恢复合同效果（限制条件、特殊规则等），确保合同限制和特殊规则在游戏过程中持续生效

### 13.3 存档版本与兼容性

- **版本号含义**  
  - 存档中的 `version` 字段用于标识存档结构与数据语义的版本。  
  - 建议采用 `major.minor.patch` 语义（实现时可用整型或字符串表示），其中：  
    - `major`：不兼容结构变更（如字段删除、语义改变）时递增；  
    - `minor/patch`：兼容性变更（新增字段、修复逻辑）时递增。
- **破坏性变更策略（Demo 阶段）**  
  - 当检测到存档版本与当前游戏版本不兼容（例如 `major` 版本不一致）时，Demo 阶段可以采用“拒绝加载并提示需要清档”的简单策略。  
  - 未来若需要长期兼容，将在后续迭代中引入 `SaveMigration` 模块，对旧版本存档进行迁移。
- **配置与存档的关系**  
  - 配置表结构（如增加字段）应尽量保持向后兼容；删除字段或改变字段语义时，应视为潜在破坏性变更，在 SPEC 文档中记录并结合存档版本策略一并考虑。  
  - 若某次配置调整会导致旧存档中的 ID 不再存在或语义发生重大变化，需在 SPEC 的“待确认问题”或变更记录区域中注明影响与处理方式。

---

## 15. 实现优先级

### 14.1 第一阶段（核心系统）
1. [ ] 时间系统和回合系统
2. [ ] 地图系统（基础格子）
3. [ ] 探险者系统（基础属性）
4. [ ] 探险队系统（选择和管理）
5. [ ] 基础探索流程

### 14.2 第二阶段（玩法系统）
1. [ ] 探索空间生成
2. [ ] 战斗系统
3. [ ] 资源收集系统
4. [ ] 勘探船基础功能

### 14.3 第三阶段（进阶系统）
1. [ ] 科技树系统
2. [ ] 天赋系统
3. [ ] 建设系统
4. [ ] 配置表系统

### 14.4 第四阶段（优化和扩展）
1. [ ] UI优化
2. [ ] 平衡性调整
3. [ ] 内容扩展
4. [ ] 性能优化

---

## 15. 技术实现建议

### 15.1 Unity架构建议
- **MVC/MVP模式**: 分离逻辑和视图
- **事件系统**: 使用UnityEvent或C#事件解耦
- **对象池**: 怪物、UI元素等使用对象池
- **单例模式**: 管理器类使用单例（谨慎使用）

### 15.2 性能优化
- **地图分块加载**: 大地图分块加载
- **资源异步加载**: 配置表和资源异步加载
- **UI优化**: 使用UI Canvas分组，减少重绘
- **对象池**: 频繁创建销毁的对象使用对象池

### 15.3 代码规范
- **命名规范**: 使用清晰的命名（PascalCase类名，camelCase变量名）
- **注释**: 关键逻辑添加注释
- **模块化**: 功能模块化，便于维护和扩展

### 15.4 日志与调试规则
- **日志等级与分类**  
  - 至少支持 Info / Warning / Error / Debug 四种日志等级。  
  - 建议使用统一的日志封装（例如 `LogSystem`），禁止在核心系统中随意使用 `Debug.Log` 分散输出。
- **日志前缀约定**  
  - 不同系统的日志应使用统一前缀，便于过滤和追踪，例如：  
    - `[TimeSystem]` 时间系统  
    - `[RoundSystem]` 回合系统  
    - `[ExplorationSystem]` 探索系统  
    - `[BattleSystem]` 战斗系统  
    - `[ResourceSystem]` 资源系统  
    - `[ShipSystem]` 勘探船系统  
    - `[SaveSystem]` 存档系统
- **关键打点要求**  
  - 以下关键事件必须有至少一条 Info 级别日志：  
    - 回合开始与结束（包含当前天数、回合数、时间段）；  
    - 探索开始与结束（包含探索点 ID、队伍成员信息）；  
    - 战斗开始与结束（包含双方单位概要与结果）；  
    - 资源结算（采集结果、消耗情况）；  
    - 存档读取与写入（包含存档版本号、主要数据摘要）。  
  - 发生 Error 级别问题（如配置缺失、数据不一致、异常崩溃前）必须输出详细错误日志。
- **调试模式**  
  - 在 Unity Editor 或开发构建中，可以开启 Debug 级别日志，以便调试；在正式发布版本中应关闭 Debug 级别日志，仅保留必要的 Info/Warning/Error。  
  - 如后续引入调试控制台/开发者工具，应在 SPEC 中补充相应规则。

---

## 16. 测试阶段特殊规则

### 16.1 角色解锁
- **默认状态**: 所有角色默认解锁
- **配置方式**: 后续通过配置表编辑属性

### 16.2 调试功能
- **时间加速**: 可添加时间加速功能（测试用）
- **资源修改**: 可添加资源修改功能（测试用）
- **状态重置**: 可添加状态重置功能（测试用）

### 16.3 系统验收标准（Demo 阶段）
- **时间与回合系统**  
  - 在多天、多时间段连续推进的情况下（包括白天/傍晚/深夜切换），时间与回合计数必须保持一致，不出现跳变或逻辑卡死。  
  - 日志中能够清晰追踪每个回合的开始、结束与时间段变化。
- **地图与探索系统**  
  - 玩家可以稳定完成一次完整的探索闭环：选择目标点 → 出发 → 到达 → 探索与战斗/挖矿 → 返回勘探船停靠点 → 资源正确结算。  
  - 地图上各类格子（勘探船停靠点、道路、探索点、空地）在视觉与交互上均符合设计。
- **战斗系统**  
  - 常见怪物与队伍组合下，战斗流程必须可重复稳定执行，不出现无限回合、战斗无法结束或数值异常。  
  - 胜负判定与死亡处理符合 SPEC 约定。
  - 医疗包治疗机制正确工作，治疗中的角色每回合恢复1点生命值，且无法触发探索技能但可以战斗。
- **资源与存档系统**  
  - 资源的获得与消耗在日志与界面上保持一致，不出现“凭空多出/消失”的情况。  
  - 在关键节点（返回勘探船停靠点、手动存档）进行存读档，不会导致数据结构损坏或核心数据丢失。
- **勘探船与功能解锁系统**  
  - 章节切换时，勘探船能正确移动到新章节的指定位置。  
  - 功能解锁条件检查正确，资源充足时可以解锁功能。  
  - 已解锁的功能在后续章节中继续可用。  
  - 功能解锁状态正确保存到存档中。

---

## 17. 待确认问题

### 17.1 设计细节
1. 探索空间中的移动规则（回合制还是实时？）
2. 战斗系统的详细规则（技能、装备等）
3. 科技树的具体科技项和效果
4. 建设系统的具体建筑类型和效果
5. 资源的具体类型和用途

### 17.2 技术细节
1. 地图大小和复杂度
2. 存档格式（JSON/Binary）
3. 配置表格式（JSON/ScriptableObject/Excel）
4. 网络功能需求（单机/联机）

---

## 18. 后续扩展方向

### 18.1 玩法扩展
- 卡牌构建系统（如需求中提到的）
- 更多角色和怪物类型
- 更多探索点类型
- 天气系统
- 事件系统

### 18.2 系统扩展
- 成就系统
- 任务系统
- 排行榜系统
- 多周目系统

---

## 19. 国际化与文本管理

### 19.1 总体原则
- 所有对玩家可见的文本（UI 文案、角色名称、资源名称与描述、技能与天赋描述、关卡与探索点名称等），都应通过统一的文本管理系统提供，不应在代码中直接硬编码具体字符串。  
- 文本采用 Key-Value 形式管理，其中 Key 在配置表与代码中引用，实际文案则由多语言文本表决定。

### 19.2 文本 Key 规范
- 文本 Key 建议采用分层命名方式，例如：  
  - `ui.main.start_button`、`ui.map.ship_name`  
  - `explorer.alice.name`、`explorer.alice.desc`  
  - `resource.metal.name`、`resource.metal.desc`  
  - `stage.abandoned_factory_1.name`、`stage.abandoned_factory_1.desc`
- 配置表中不直接存中文文案，而是存对应的文本 Key（如 `nameKey`、`descKey`），运行时通过 `LanguageManager` 或类似模块根据当前语言加载实际文案。

### 19.3 语言与运行时切换
- **语言支持策略（Demo 阶段）**  
  - 当前仅强制支持简体中文（`zh-CN`），但所有文本结构设计需预留英文（`en-US`）等多语言扩展空间。  
  - 文本表格式需支持为同一 Key 提供多种语言版本（例如每条记录包含 `key`, `zhCN`, `enUS` 等字段）。
- **运行时语言切换**  
  - 提供集中管理当前语言状态的模块（如 `LanguageManager`），负责：  
    - 记录当前语言枚举值；  
    - 根据语言与 Key 返回对应字符串；  
    - 触发 UI 文本刷新（例如通过观察者模式或事件系统）。
  - 当前语言的选择可保存在设置或存档中，以便下次启动时恢复。

### 19.4 与配置表的关系
- `ExplorerConfig`、`ResourceConfig`、`ItemConfig`、`ExplorationPointConfig` 等配置表中涉及展示给玩家的名称与描述时：  
  - 应使用 `nameKey`/`descKey` 字段引用文本 Key，而不是直接写死文案。  
  - 多语言扩展时，只需要在文本表中为这些 Key 填入对应语言的内容，无需修改配置表结构。

---

## 附录

### A. 术语表
- **回合**: 30分钟的游戏时间单位
- **格子**: 地图上的最小单位
- **探索点**: 可进行探索的格子类型
- **矿物**: 探索棋盘中的原始矿物资源
- **科技点**: 解锁科技树的资源
- **专属道具**: 用于升级天赋或解锁科技的道具

### B. 参考文档
- Unity官方文档
- 游戏设计文档（待补充）
- 配置表模板（待创建）

---

## 20. 开发变更记录

### 2024-12-10 世界观与系统重大变更

#### 世界观变更
1. **世界观从避难所打僵尸变为勘探船挖矿打虫子**
   - 游戏背景从末日生存改为太空勘探
   - 敌人从僵尸改为虫族
   - 资源收集从采集改为挖矿
   - 基地从避难所改为勘探船

2. **探险队系统与勘探船系统合并**
   - 勘探船就是探险小队，两者概念合并
   - 移动方式从小队单独移动变为勘探船移动
   - 勘探船既是移动基地，也是探险小队本身

#### 设计理念变更
1. **勘探船从固定建筑变为移动基地**
   - 勘探船不再是一个固定在地图上的建筑
   - 勘探船随章节推进而移动，每个章节对应不同的停靠点位置
   - 勘探船的外观和功能列表随章节变化

2. **功能从建设系统改为功能解锁系统**
   - 废弃原有的建设系统（在地图上建设固定建筑）
   - 改为通过消耗资源解锁章节功能
   - 功能解锁与任务系统挂钩，推进主线剧情

3. **勘探船功能重新定义**
   - 基础功能：角色管理、资源存储、停靠点（所有章节通用）
   - 章节功能：按章节解锁，包括角色强化、装备制作、科技研究、天赋升级等
   - 功能解锁需要消耗资源，形成资源挖矿→功能解锁→推进主线的循环

#### 具体变更内容
- **1.1 游戏核心玩法**：更新世界观描述，从避难所打僵尸改为勘探船挖矿打虫子
- **1.2 核心循环**：更新准备阶段，从选择探险队改为勘探船移动
- **第6章 探险队系统**：重写为勘探船系统，勘探船就是探险小队
- **第7章 探索系统**：更新探索流程，从避难所出发改为从勘探船出发
- **第8章 战斗系统**：更新战斗描述，从僵尸改为虫族
- **第9章 资源系统**：更新资源收集为资源挖矿
- **第10章 避难所系统**：重写为勘探船系统
  - **10.1 勘探船系统概述**：重新定义为核心系统
  - **10.2 勘探船功能**：重新定义为基础功能和章节功能
  - **10.3 勘探船与章节的关系**：移动基地机制
  - **10.4 功能解锁流程**：详细的解锁条件和流程
  - **10.5 勘探船数据结构**：更新数据结构定义
  - **10.6 勘探船界面设计**：功能列表和解锁界面
  - **10.7 勘探船与任务系统的集成**：任务驱动解锁
- **第22章 章节系统**：
  - **22.2.2 章节解锁机制**：添加勘探船移动步骤
  - **22.3 章节数据结构**：添加功能ID列表和勘探船停靠点位置
  - **22.4.1 章节配置表**：添加可解锁功能ID列表和停靠点坐标
  - **22.5.2 章节解锁检查**：添加勘探船移动逻辑
  - **22.6.4 与勘探船系统集成**：新增章节系统与勘探船系统的集成说明

#### 配置表变更
- **废弃**: `ShelterLevelConfig`（勘探船等级配置表，如保留等级系统）
- **新增**: `ShipFeatureConfig`（功能配置表，原 `ShelterFeatureConfig`）
- **扩展**: `ChapterConfig`（添加可解锁功能ID列表和停靠点坐标）
- **术语更新**: `GarbageConfig` 语义从"垃圾"改为"矿物"（配置表名称可保留或改为 `MineralConfig`）

---

### 2024-12-10 变更记录（旧）

#### 功能新增与规则明确

1. **战斗后自动矿物产出机制**（8.3节）
   - 战斗结算完成后，按棋盘编号从小到大自动处理所有矿物格子
   - 先尝试触发"进阶产出机制"，未触发则使用"默认搜索产出"
   - 产出自动应用到探险队背包，无需玩家手动操作

2. **负值产出处理规则**（9.2节）
   - 支持负值产出（如 `resource_food_-1`），从背包中减少对应资源
   - 如果背包中没有该资源或数量不足，则不减少（不会扣到负数）

3. **背包界面功能**（12.3节）
   - 在探索界面底部添加"背包"按钮
   - 点击后打开背包面板，显示所有队员的背包内容
   - 支持查看每个队员的背包状态（当前版本为只读）

4. **探索棋盘刷新规则**（7.3节）
   - 每次进入新的一层探索棋盘时，必须对所有单位进行随机位置刷新
   - 角色、虫族、矿物的位置必须完全重新随机化，不能保留上一层的位置

#### BUG修复与规则修正

1. **探索点位置配置修正**（11.1.5节）
   - 明确探索点的位置坐标由 `MapConfig` 决定，而非 `ExplorationPointConfig` 中的位置字段
   - 探索点通过 `MapConfig.资源生成规则ID` 字段与探索点ID关联

2. **探险队位置持久化规则**（6.2节）
   - 探险队在大地图上的位置在整个探索过程中持续保持
   - 从当前位置出发（而非总是从避难所出发）
   - 时间连续，回合数不会重置
   - 成员锁定，在外探索时不可更换

3. **地图坐标系统说明**（4.1节）
   - 明确UI渲染时X轴为垂直方向（行），Y轴为水平方向（列）
   - 明确寻路规则和格子可通行性

4. **时间段划分修正**（2.2节）
   - 更正时间段的具体回合范围
   - 明确UI颜色区分规则（白天白色、傍晚橙色、深夜紫色）

5. **配置表格式统一**（11.1.5节）
   - `ExplorationPointConfig` 中的"棋盘出现内容"字段统一为单一字段，支持字符串和数组两种格式
   - 虫族和矿物的生成规则合并到同一个配置字段中

6. **多语言系统实现**（19节）
   - 实现了多语言文本管理系统（`LanguageManager`）
   - 配置表使用 `nameKey`/`descKey` 引用文本Key
   - 支持通过 `LocalizationConfig` CSV模板管理多语言文案

#### 代码架构调整

1. **移除手动采集逻辑**
   - 移除了探索棋盘上的"采集"按钮
   - 垃圾改为战斗后自动处理，提升游戏流畅度

2. **战斗系统扩展**
   - 新增 `processGarbageAfterBattle` 函数，处理战斗后的垃圾产出
   - 战斗流程中集成垃圾产出处理步骤

3. **资源分配系统扩展**
   - 新增 `removeFromExplorerInventory` 函数，支持负值产出处理
   - `distributeLootToExplorers` 函数支持负值处理逻辑

---

## 21. 任务系统设计

### 21.1 任务系统概述

任务系统是引导玩家游戏进程、提供明确目标与奖励的核心系统。通过任务系统，玩家可以获得游戏指引，了解当前应该完成的目标，并获得相应的奖励。

任务系统与核心循环的关系：
- **准备阶段**：任务可能要求玩家选择特定角色或准备特定资源
- **探索阶段**：任务可能要求玩家探索特定地点或收集特定资源
- **战斗/收集阶段**：任务可能要求玩家击败特定怪物或收集特定物品
- **返回阶段**：任务可能要求玩家返回勘探船停靠点
- **功能解锁阶段**：任务可能要求玩家解锁特定功能或升级勘探船
- **回合推进**：任务触发条件可能在回合推进时检查

### 21.2 任务机制设计

#### 21.2.1 自动领取机制

- **触发条件类型**：
  - **回合数触发**：达到特定回合数时自动领取
  - **前置任务触发**：完成指定前置任务后自动领取
  - **资源触发**：拥有特定资源达到指定数量时自动领取
  - **探索触发**：完成特定探索点后自动领取
  - **战斗触发**：击败特定怪物达到指定数量后自动领取
  - **勘探船等级触发**：勘探船达到指定等级时自动领取（如保留等级系统）

- **触发条件检查时机**：
  - 每回合开始时检查回合数触发条件
  - 资源变化时检查资源触发条件
  - 任务完成时检查前置任务触发条件
  - 探索完成时检查探索触发条件
  - 战斗结束时检查战斗触发条件
  - 勘探船升级时检查勘探船等级触发条件（如保留等级系统）

- **自动领取规则**：
  - 满足触发条件时，任务自动从"未触发"状态转为"已领取"状态
  - 同一时间可以存在多个已领取的任务
  - 任务领取后立即开始追踪完成条件

#### 21.2.2 任务完成机制

- **完成条件类型**：
  - **收集资源**：收集指定资源达到目标数量（如：收集食物 10/20）
  - **击败怪物**：击败指定虫族达到目标数量（如：击败虫族 5/10）
  - **探索完成**：完成指定探索点达到目标次数（如：探索医院 1/3）
  - **建设完成**：建设指定建筑达到目标数量（如：建设资源站 2/5）
  - **回合数达到**：游戏进行到指定回合数（如：存活 48/48 回合）

- **完成条件动态更新**：
  - 任务条件显示格式：`当前值/目标值`（如"收集食物 10/20"）
  - 当前值实时更新：
    - 资源收集类：监听所有角色的背包变化，统计指定资源的总数量
    - 击败怪物类：监听战斗结果，统计击败的指定怪物数量
    - 探索完成类：监听探索完成事件，统计完成的指定探索点次数
    - 建设完成类：监听建设完成事件，统计建设的指定建筑数量
    - 回合数类：监听回合推进事件，统计当前回合数

- **手动完成规则**：
  - 玩家需要手动点击"完成任务"按钮
  - 点击时检查完成条件是否满足
  - 如果满足，任务状态转为"已完成"
  - 如果未满足，显示提示信息

#### 21.2.3 奖励领取机制

- **奖励类型**：
  - **资源奖励**：奖励指定数量的资源（如：食物 10、金属 5）
  - **道具奖励**：奖励指定数量的道具（如：医疗包 2）
  - **经验奖励**：奖励经验值（如果有经验系统）

- **奖励发放规则**：
  - 任务完成后，玩家需要手动点击"领取奖励"按钮
  - 点击后，奖励自动发放到玩家库存：
    - 资源奖励：通过 `distributeLootToExplorers` 分配到角色背包
    - 道具奖励：通过 `distributeLootToExplorers` 分配到角色背包
    - 经验奖励：如果存在经验系统，则增加角色经验值
  - 奖励领取后，任务状态转为"已领取奖励"

#### 21.2.4 自动接取下一任务

- **任务链设计**：
  - 每个任务可以配置 `nextQuestId`，指向下一个任务
  - 当任务完成并领取奖励后，自动检查是否存在下一个任务
  - 如果存在，检查下一个任务的触发条件是否满足
  - 如果满足，自动领取下一个任务
  - 如果不满足，等待触发条件满足后再自动领取

- **任务序列规则**：
  - 任务链可以形成线性序列（任务1 → 任务2 → 任务3）
  - 也可以形成分支序列（任务1 → 任务2a 或 任务2b）
  - 分支任务需要分别配置不同的 `nextQuestId`

### 21.3 任务界面设计

#### 21.3.1 界面位置

- **位置**：界面右侧上方常驻显示
- **布局**：固定位置，不随地图滚动而移动
- **层级**：位于其他UI元素之上，但不遮挡核心操作区域

#### 21.3.2 界面内容

- **任务列表**：
  - 显示当前所有"已领取"状态的任务
  - 按优先级（priority）排序显示
  - 每个任务显示为一个任务卡片

- **任务卡片内容**：
  - **任务名称**：使用多语言Key显示任务名称
  - **任务描述**：使用多语言Key显示任务描述
  - **任务条件**：动态显示完成条件（格式：`当前值/目标值`）
    - 例如："收集食物 10/20"
    - 例如："击败虫族 5/10"
  - **完成任务按钮**：
    - 当完成条件满足时，按钮可用（可点击）
    - 当完成条件未满足时，按钮禁用（灰色，不可点击）
    - 点击后检查条件，满足则完成任务
  - **领取奖励按钮**：
    - 仅在任务状态为"已完成"且未领取奖励时显示
    - 点击后发放奖励并更新任务状态

- **任务状态显示**：
  - 已完成的任务高亮显示（如：绿色边框或背景）
  - 可领取奖励的任务闪烁提示（可选）

#### 21.3.3 界面交互

- **实时更新**：
  - 任务条件实时更新（资源变化、战斗结果等触发更新）
  - 更新频率：每次相关事件发生时立即更新

- **折叠/展开**：
  - 任务列表可以折叠/展开（可选功能）
  - 折叠时只显示任务数量，展开时显示完整任务列表

- **任务详情**：
  - 点击任务卡片可以展开/折叠任务详情（可选功能）
  - 详情中显示完整的任务描述和奖励信息

### 21.4 任务数据结构

```csharp
// 伪代码结构
Quest {
    string questId;                    // 任务ID
    string nameKey;                    // 任务名称（多语言Key）
    string descKey;                    // 任务描述（多语言Key）
    QuestStatus status;                // 任务状态：未触发/已领取/已完成/已领取奖励
    QuestTriggerCondition triggerCondition;  // 触发条件
    QuestCompletionCondition completionCondition;  // 完成条件
    QuestReward reward;                // 奖励
    string nextQuestId;                // 下一个任务ID（任务链）
    int priority;                      // 优先级（用于排序显示）
}

QuestStatus {
    NotTriggered,      // 未触发
    Accepted,         // 已领取
    Completed,        // 已完成
    RewardClaimed     // 已领取奖励
}

QuestTriggerCondition {
    TriggerType type;                  // 触发类型：回合数、前置任务、资源等
    Dictionary<string, object> params; // 触发条件参数
}

TriggerType {
    RoundReached,     // 回合数达到
    QuestCompleted,   // 前置任务完成
    ResourceOwned,    // 拥有资源
    ExplorationCompleted, // 探索完成
    MonsterDefeated,  // 击败怪物
    ShipLevelReached    // 勘探船等级达到（如保留等级系统）
}

QuestCompletionCondition {
    ConditionType type;                // 条件类型：收集资源、击败怪物、探索完成等
    string targetId;                   // 目标ID（如资源ID、怪物ID）
    int targetValue;                   // 目标值
    int currentValue;                  // 当前值（动态更新）
}

ConditionType {
    CollectResource,  // 收集资源
    DefeatMonster,    // 击败怪物
    CompleteExploration, // 完成探索
    BuildFacility,    // 建设建筑
    ReachRound        // 达到回合数
}

QuestReward {
    List<ResourceReward> resources;   // 资源奖励
    List<ItemReward> items;           // 道具奖励
    int experience;                    // 经验奖励（如果有）
}

ResourceReward {
    string resourceId;                // 资源ID
    int quantity;                     // 数量
}

ItemReward {
    string itemId;                     // 道具ID
    int quantity;                      // 数量
}
```

### 21.5 任务配置表设计

#### 21.5.1 任务配置表 (QuestConfig)

任务配置表采用 JSON 格式，与现有配置表系统保持一致。

**字段定义**：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| ID | string | 任务ID（唯一标识） | "quest_001" |
| 名称Key | string | 任务名称的多语言Key | "quest_001_name" |
| 描述Key | string | 任务描述的多语言Key | "quest_001_desc" |
| 触发条件类型 | string | 触发条件类型 | "RoundReached" |
| 触发条件参数 | string | 触发条件参数（JSON字符串或键值对） | "{\"round\": 10}" |
| 完成条件类型 | string | 完成条件类型 | "CollectResource" |
| 完成条件目标ID | string | 完成条件目标ID（资源ID、怪物ID等） | "resource_food" |
| 完成条件目标值 | number | 完成条件目标值 | 20 |
| 奖励资源列表 | string | 奖励资源列表（格式：资源ID_数量\|资源ID_数量） | "resource_food_10\|resource_metal_5" |
| 奖励道具列表 | string | 奖励道具列表（格式：道具ID_数量\|道具ID_数量） | "item_medkit_2" |
| 下一个任务ID | string | 任务链中的下一个任务ID（可选） | "quest_002" |
| 优先级 | number | 优先级（用于界面排序，数字越小优先级越高） | 1 |

**触发条件类型与参数格式**：

- **RoundReached**（回合数达到）：
  - 参数：`{"round": 10}` 表示第10回合时触发

- **QuestCompleted**（前置任务完成）：
  - 参数：`{"questId": "quest_001"}` 表示完成 quest_001 后触发

- **ResourceOwned**（拥有资源）：
  - 参数：`{"resourceId": "resource_food", "quantity": 5}` 表示拥有5个食物时触发

- **ExplorationCompleted**（探索完成）：
  - 参数：`{"explorationPointId": "point_hospital"}` 表示完成医院探索点后触发

- **MonsterDefeated**（击败怪物）：
  - 参数：`{"monsterId": "monster_bug", "quantity": 3}` 表示击败3个虫族后触发

- **ShipLevelReached**（勘探船等级达到，如保留等级系统）：
  - 参数：`{"level": 2}` 表示勘探船达到2级时触发

**完成条件类型与目标ID**：

- **CollectResource**（收集资源）：
  - 目标ID：资源ID（如 "resource_food"）
  - 目标值：需要收集的数量

- **DefeatMonster**（击败怪物）：
  - 目标ID：虫族ID（如 "monster_bug"）
  - 目标值：需要击败的数量

- **CompleteExploration**（完成探索）：
  - 目标ID：探索点ID（如 "point_hospital"）
  - 目标值：需要完成的次数

- **BuildFacility**（建设建筑）：
  - 目标ID：建筑类型ID（如 "facility_resource_station"）
  - 目标值：需要建设的数量

- **ReachRound**（达到回合数）：
  - 目标ID：固定为 "round"
  - 目标值：需要达到的回合数

### 21.6 任务系统实现要点

#### 21.6.1 任务状态管理

- **状态维护**：
  - 维护当前所有任务的状态（未触发、已领取、已完成、已领取奖励）
  - 使用 Map<string, Quest> 存储任务，key 为 questId

- **状态持久化**：
  - 任务状态需要保存到存档中
  - 存档时保存所有任务的状态和当前值
  - 读档时恢复任务状态和当前值

#### 21.6.2 条件检查系统

- **资源收集条件检查**：
  - 监听所有角色的背包变化事件
  - 统计指定资源在所有角色背包中的总数量
  - 更新对应任务的当前值

- **战斗条件检查**：
  - 监听战斗结果事件
  - 统计击败的指定怪物数量
  - 更新对应任务的当前值

- **探索条件检查**：
  - 监听探索完成事件
  - 统计完成的指定探索点次数
  - 更新对应任务的当前值

- **回合数条件检查**：
  - 监听回合推进事件
  - 更新回合数类任务的当前值

#### 21.6.3 任务界面组件

- **QuestPanel 组件**：
  - 使用 React 创建
  - 位置：界面右侧上方（固定定位）
  - 实时更新任务条件进度
  - 提供完成任务和领取奖励的交互按钮

### 21.7 任务系统与现有系统的集成

#### 21.7.1 与资源系统集成

- 监听资源变化事件（角色背包变化）
- 更新收集资源类任务的当前值
- 检查资源触发条件是否满足

#### 21.7.2 与战斗系统集成

- 监听战斗结果事件（怪物被击败）
- 更新击败怪物类任务的当前值
- 检查战斗触发条件是否满足

#### 21.7.3 与探索系统集成

- 监听探索完成事件（探索点完成）
- 更新探索完成类任务的当前值
- 检查探索触发条件是否满足

#### 21.7.4 与回合系统集成

- 在回合推进时检查回合数触发条件
- 更新回合数类任务的当前值
- 在回合开始时统一检查所有触发条件

#### 21.7.5 与存档系统集成

- 任务状态需要保存到存档中
- 包括：任务ID、任务状态、当前值
- 读档时恢复任务状态和进度

---

## 22. 章节系统设计

### 22.1 章节系统概述

章节系统是游戏进程管理的高层系统，用于组织游戏内容的分阶段推进。每个章节包含1到N张地图，玩家需要完成章节内的特定任务才能解锁下一章节。

章节系统与核心循环的关系：
- **章节层级**：章节 > 地图 > 探索点
- **章节解锁**：通过完成特定任务解锁新章节
- **剧情展示**：新章节解锁时显示剧情段落（包括第一章）
- **地图切换**：章节切换时加载对应章节的地图配置

### 22.2 章节机制设计

#### 22.2.1 章节结构

- **章节层级关系**：
  - 每个章节（Chapter）包含1到N张地图（Map）
  - 每张地图包含多个探索点、勘探船停靠点等格子
  - 当前大地图是章节1的第一张地图

- **章节数据结构**：
  ```
  章节1
    ├─ 地图1（当前大地图）
    ├─ 地图2（待解锁）
    └─ 地图N
  章节2（待解锁）
    ├─ 地图1
    └─ 地图2
  ```

#### 22.2.2 章节解锁机制

- **解锁条件**：
  - 章节解锁与任务系统挂钩
  - 当玩家完成特定任务（章节结束任务）时，当前章节结束并解锁下一章节
  - 章节结束任务在任务配置中标记为 `章节结束任务`

- **解锁流程**：
  1. 玩家完成章节结束任务
  2. 系统检测到章节结束任务完成
  3. 当前章节标记为"已完成"
  4. 下一章节标记为"已解锁"
  5. **勘探船移动到新章节**（移动基地机制）
  6. 显示新章节的剧情段落
  7. 切换到新章节的第一张地图
  8. 解锁新章节的可解锁功能列表

#### 22.2.3 剧情展示机制

- **剧情触发时机**：
  - 新章节解锁时自动显示剧情段落
  - 包括第一章（游戏开始时显示）
  - 玩家可以点击"继续"按钮关闭剧情界面

- **剧情内容**：
  - 剧情文本使用多语言Key
  - 支持多段剧情文本（分段显示或一次性显示）
  - 剧情界面全屏或半屏遮罩显示

### 22.3 章节数据结构

```csharp
// 伪代码结构
Chapter {
    string chapterId;              // 章节ID
    string nameKey;                // 章节名称（多语言Key）
    string storyKey;               // 剧情文本Key（多语言Key，支持多段文本）
    int chapterNumber;             // 章节编号（1, 2, 3...）
    ChapterStatus status;          // 章节状态：未解锁/已解锁/进行中/已完成
    string[] mapIds;               // 该章节包含的地图ID列表
    string unlockQuestId;          // 解锁该章节所需的任务ID（章节结束任务）
    string[] featureIds;           // 该章节可解锁的功能ID列表
    WorldPosition shipDockPosition; // 该章节勘探船停靠点的位置坐标
    int priority;                  // 优先级（用于排序）
}

ChapterStatus {
    Locked,        // 未解锁
    Unlocked,      // 已解锁（可进入）
    InProgress,    // 进行中
    Completed      // 已完成
}

ChapterMap {
    string mapId;                  // 地图ID
    string chapterId;              // 所属章节ID
    int mapIndex;                  // 在该章节中的索引（1, 2, 3...）
    MapConfigEntry[] mapCells;     // 地图格子配置
}
```

### 22.4 章节配置表设计

#### 22.4.1 章节配置表 (ChapterConfig)

**字段定义**：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| ID | string | 章节ID（唯一标识） | "chapter_001" |
| 名称Key | string | 章节名称的多语言Key | "chapter_001_name" |
| 剧情Key | string | 剧情文本的多语言Key | "chapter_001_story" |
| 章节编号 | number | 章节编号（1, 2, 3...） | 1 |
| 地图ID列表 | string | 该章节包含的地图ID列表（以\|分隔） | "map_001\|map_002" |
| 解锁任务ID | string | 解锁该章节所需的任务ID（上一章节的结束任务） | "quest_chapter_end_001" |
| 可解锁功能ID列表 | string | 该章节可解锁的功能ID列表（以\|分隔） | "feature_001\|feature_002" |
| 停靠点X坐标 | number | 该章节勘探船停靠点在地图上的X坐标 | 10 |
| 停靠点Y坐标 | number | 该章节勘探船停靠点在地图上的Y坐标 | 10 |
| 优先级 | number | 优先级（用于排序） | 1 |

#### 22.4.2 章节地图关联

- **地图配置扩展**：
  - 在 `MapConfig` 中新增字段 `所属章节ID` 和 `地图索引`
  - 或创建独立的 `ChapterMapConfig` 配置表，关联章节和地图

- **地图加载规则**：
  - 根据当前章节和地图索引加载对应的地图配置
  - 未解锁的地图不加载到游戏中

### 22.5 章节系统实现要点

#### 22.5.1 章节状态管理

- **状态维护**：
  - 维护当前所有章节的状态（未解锁、已解锁、进行中、已完成）
  - 使用 Map<string, Chapter> 存储章节，key 为 chapterId

- **状态持久化**：
  - 章节状态需要保存到存档中
  - 包括：当前章节ID、已解锁章节列表、已完成章节列表

#### 22.5.2 章节解锁检查

- **任务完成监听**：
  - 监听任务完成事件
  - 检查完成的任务是否为章节结束任务
  - 如果是，触发章节解锁流程

- **章节切换**：
  - 解锁新章节后，自动切换到新章节的第一张地图
  - **勘探船移动到新章节的指定停靠点**（移动基地机制）
  - 加载新章节的地图配置
  - 重置勘探船位置到新章节的停靠点位置
  - 解锁新章节的可解锁功能列表

#### 22.5.3 剧情展示组件

- **ChapterStoryPanel 组件**：
  - 使用 React 创建
  - 全屏或半屏遮罩显示
  - 显示章节名称和剧情文本
  - 提供"继续"按钮关闭剧情界面
  - 支持多段剧情文本（分段显示或滚动显示）

### 22.6 章节系统与现有系统的集成

#### 22.6.1 与任务系统集成

- 任务配置中新增字段 `是否章节结束任务`（isChapterEndQuest）
- 当章节结束任务完成时，触发章节解锁
- 章节解锁任务作为特殊的任务类型

#### 22.6.2 与地图系统集成

- 根据当前章节加载对应的地图配置
- 地图切换时更新 `MapSystem` 实例
- **勘探船位置随章节切换**：章节切换时，勘探船移动到新章节的指定停靠点位置
- 勘探船位置重置到新章节的停靠点位置

#### 22.6.4 与勘探船系统集成

- 章节切换时，勘探船移动到新章节的指定停靠点位置
- 解锁新章节的可解锁功能列表
- 已解锁的功能在后续章节中继续可用

#### 22.6.3 与存档系统集成

- 章节状态需要保存到存档中
- 包括：当前章节ID、已解锁章节列表、已完成章节列表
- 读档时恢复章节状态和当前地图

---

## 23. 装备系统设计

### 23.1 装备系统概述

装备系统允许角色装备特定数量的装备，装备的主要功能是用于探索棋盘中激活进阶产出效果。每个角色可以装备"N"个装备（N为角色属性中的装备槽位数量）。

装备系统与核心循环的关系：
- **装备管理**：在避难所或角色界面中管理装备的穿戴和卸下
- **探索效果**：装备在探索棋盘中的进阶产出机制评估时生效
- **装备限制**：每个角色有固定的装备槽位数量，不能超过

### 23.2 装备机制设计

#### 23.2.1 装备槽位

- **槽位数量**：
  - 每个角色有固定的装备槽位数量（`equipmentSlots`）
  - 装备槽位数量作为角色属性，在角色配置表中定义
  - 角色可以装备的装备数量不能超过槽位数量

- **装备状态**：
  - 每个装备槽位可以装备一个装备，也可以为空
  - 装备可以随时穿戴和卸下
  - 卸下的装备返回角色背包（如果背包有空间）

#### 23.2.2 装备效果

- **效果类型**：
  - 装备主要用于激活探索棋盘中的进阶产出机制
  - 装备效果在进阶产出条件评估时生效
  - 支持多种效果类型（如：增加特定矿物类型的触发概率、提供特定标签等）

- **效果评估时机**：
  - 在探索棋盘生成后，处理垃圾产出时
  - 在 `AdvancedOutputEvaluationContext` 中考虑角色的装备效果
  - 装备效果影响进阶产出机制的触发条件判断

#### 23.2.3 装备与进阶产出机制

- **装备标签系统**：
  - 装备可以拥有"标签"（如：工具、武器、防护等）
  - 进阶产出机制可以通过检查角色装备的标签来触发
  - 例如：当队伍中有2个角色装备了"工具"标签的装备时，触发特定进阶产出

- **装备类型匹配**：
  - 装备可以匹配特定的垃圾类型
  - 当角色装备了匹配的装备时，更容易触发对应垃圾类型的进阶产出

### 23.3 装备数据结构

```csharp
// 伪代码结构
Equipment {
    string equipmentId;          // 装备ID
    string nameKey;              // 装备名称（多语言Key）
    string descKey;               // 装备描述（多语言Key）
    string[] tags;                // 装备标签列表（如：工具、武器、防护等）
    string[] matchedGarbageTypes; // 匹配的垃圾类型列表
    EquipmentEffect effect;       // 装备效果
    int maxStack;                 // 堆叠最大数量（如果装备可以作为道具）
}

EquipmentEffect {
    EffectType type;              // 效果类型
    Dictionary<string, object> params; // 效果参数
}

EffectType {
    ProvideTag,           // 提供标签（用于进阶产出条件检查）
    MatchGarbageType,     // 匹配垃圾类型
    BoostAdvancedOutput   // 提升进阶产出概率
}
```

### 23.4 角色数据结构扩展

```csharp
Explorer {
    // ... 现有字段 ...
    int equipmentSlots;           // 装备槽位数量（从配置表读取）
    string[] equipment;           // 当前装备的装备ID列表（长度 <= equipmentSlots）
}
```

### 23.5 装备配置表设计

#### 23.5.1 装备配置表 (EquipmentConfig)

**字段定义**：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| ID | string | 装备ID（唯一标识） | "equipment_tool_001" |
| 名称Key | string | 装备名称的多语言Key | "equipment_tool_001_name" |
| 描述Key | string | 装备描述的多语言Key | "equipment_tool_001_desc" |
| 装备标签列表 | string | 装备标签列表（以\|分隔） | "工具\|金属" |
| 匹配垃圾类型列表 | string | 匹配的垃圾类型列表（以\|分隔） | "废金属\|电子元件" |
| 效果类型 | string | 效果类型 | "ProvideTag" |
| 效果参数 | string | 效果参数（JSON字符串或键值对） | "Tag=工具;Boost=0.1" |
| 堆叠最大数量 | number | 堆叠最大数量（如果装备可以作为道具） | 1 |

### 23.6 进阶产出机制扩展

#### 23.6.1 新增触发条件类型

- **EquipmentCount**（装备数量）：
  - 参数示例："EquipmentTag=工具;MinCount=2"
  - 逻辑：统计 explorers 中装备了指定标签装备的角色数量，数量 >= MinCount 则返回 true

- **EquipmentMatchGarbageType**（装备匹配垃圾类型）：
  - 参数示例："GarbageType=废金属;MinCount=1"
  - 逻辑：统计 explorers 中装备了匹配指定垃圾类型装备的角色数量，数量 >= MinCount 则返回 true

### 23.7 装备系统实现要点

#### 23.7.1 装备管理

- **穿戴装备**：
  - 检查角色装备槽位是否已满
  - 检查装备是否在角色背包中
  - 将装备从背包移除，添加到装备槽位

- **卸下装备**：
  - 将装备从装备槽位移除
  - 尝试将装备放回角色背包（如果背包有空间）
  - 如果背包已满，装备保留在槽位中（或提示玩家）

#### 23.7.2 装备效果应用

- **进阶产出评估**：
  - 在 `AdvancedOutputEvaluationContext` 中包含角色的装备信息
  - 在进阶产出条件处理器中检查装备标签和效果
  - 根据装备效果调整进阶产出触发条件

#### 23.7.3 装备界面

- **装备管理界面**：
  - 在角色详情或背包界面中显示装备槽位
  - 支持拖拽或点击穿戴/卸下装备
  - 显示装备效果和标签

### 23.8 装备系统与现有系统的集成

#### 23.8.1 与角色系统集成

- 角色配置表中添加 `装备槽位数量` 字段
- 角色数据结构中添加 `equipment` 字段
- 角色初始化时设置装备槽位数量

#### 23.8.2 与探索系统集成

- 在探索棋盘生成时，考虑角色的装备效果
- 在进阶产出机制评估时，检查角色的装备标签和效果

#### 23.8.3 与背包系统集成

- 装备可以作为道具存储在背包中
- 穿戴装备时从背包移除，卸下时放回背包

#### 23.8.4 与存档系统集成

- 装备状态需要保存到存档中
- 包括：每个角色的装备列表

---

## 24. 怪物入侵系统设计

### 24.1 怪物入侵系统概述

怪物入侵系统是游戏的核心防御机制，当玩家在挖掘点挖掘时，震动值会累积，达到最大值时触发怪物入侵。入侵怪物会攻击勘探船和防御设施，玩家需要依靠防御设施进行自动防御。

**核心设计理念**：
- **震动值累积**：每回合自动增加，道具触发时也会增加
- **即时制战斗**：入侵战斗采用即时制，怪物和设施自动战斗
- **防御设施**：玩家可以建造和升级防御设施进行防御
- **游戏失败条件**：船体血量降为0时游戏失败

### 24.2 震动值系统

#### 24.2.1 震动值计算规则
- **每回合增加**：勘探船每回合默认增加震动值（`baseVibrationPerRound`），可通过升级降低
- **道具触发**：某些道具使用时会增加震动值（在 `ItemConfig.增加震动值` 中配置）
- **震动值上限**：每个探索点独立配置震动值最大值（`ExplorationPointConfig.震动值最大值`）

#### 24.2.2 震动值触发条件
- 当震动值达到探索点配置的最大值时，立即触发怪物入侵
- 触发后，暂停原有的回合制战斗，优先处理入侵战斗

### 24.3 怪物入侵机制

#### 24.3.1 入侵怪物生成
- **生成规则**：根据探索点配置的"入侵怪物配置列表"（`ExplorationPointConfig.入侵怪物配置列表`）生成
- **怪物类型**：分为近战（melee）和远程（ranged）两种类型
- **生成位置**：怪物在探索棋盘上随机生成，近战怪物会移动到边缘，远程怪物可以停留在棋盘内

#### 24.3.2 怪物行为
- **近战怪物**：
  - 移动到探索棋盘最近的边缘位置
  - 攻击相邻的设施或船体
  - 优先攻击设施，如果没有设施则攻击船体
- **远程怪物**：
  - 可以停留在探索棋盘内任意位置
  - 直接攻击外围的设施或船体
  - 攻击范围更大

### 24.4 即时制战斗系统

#### 24.4.1 战斗循环
- **战斗频率**：每100ms执行一次战斗计算（10次/秒）
- **战斗流程**：
  1. 更新怪物目标（优先攻击设施）
  2. 防御设施自动攻击范围内的怪物
  3. 怪物攻击设施或船体
  4. 检查胜利/失败条件

#### 24.4.2 战斗暂停机制
- 当怪物入侵触发时，暂停原有的回合制战斗
- 入侵期间，"下一回合"按钮禁用，显示"防御中..."
- 入侵结束后，恢复回合制战斗

### 24.5 防御设施系统

#### 24.5.1 设施类型
- **炮台**：攻击型设施，自动攻击范围内的怪物
- **护盾**：防御型设施，提供额外保护（可选实现）

#### 24.5.2 设施属性
- **血量**：设施被攻击时会减少血量，血量为0时被摧毁
- **攻击力**：炮台设施的攻击力
- **攻击范围**：设施的攻击范围（格子数）
- **攻击速度**：每秒攻击次数
- **等级**：设施可以升级，提升属性

#### 24.5.3 设施位置
- 防御设施放置在探索棋盘外围位置：
  - 上边缘：y = -1, x = 0-5
  - 下边缘：y = 4, x = 0-5
  - 左边缘：x = -1, y = 0-3
  - 右边缘：x = 6, y = 0-3

#### 24.5.4 设施建造与升级
- **建造**：消耗资源建造设施（在 `DefenseFacilityConfig.建造消耗资源列表` 中配置）
- **升级**：消耗资源升级设施（在 `DefenseFacilityConfig.升级消耗资源列表` 中配置）
- **升级效果**：提升血量上限和攻击力

### 24.6 勘探船系统扩展

#### 24.6.1 船体属性
- **初始血量**：勘探船初始血量（在 `ShipConfig.初始血量` 中配置）
- **最大血量**：勘探船最大血量（在 `ShipConfig.最大血量` 中配置）
- **每回合震动值增加值**：勘探船每回合默认增加的震动值（在 `ShipConfig.每回合震动值增加值` 中配置）

#### 24.6.2 船体升级
- 可以通过升级降低每回合震动值增加值
- 可以通过升级提升船体最大血量

### 24.7 游戏失败处理

#### 24.7.1 失败条件
- 当勘探船船体血量降为0时，触发游戏失败
- 显示游戏失败界面
- 提供"重新开始"或"返回主菜单"选项

#### 24.7.2 胜利条件
- 当所有入侵怪物被消灭时，入侵战斗胜利
- 重置震动值为0
- 恢复回合制战斗

### 24.8 配置表扩展

#### 24.8.1 ExplorationPointConfig 扩展
- `震动值最大值`: number - 每个探索点独立配置
- `入侵怪物配置列表`: string | string[] - 格式同"棋盘出现内容"

#### 24.8.2 ItemConfig 扩展
- `增加震动值`: number - 道具触发时增加的震动值（可选）

#### 24.8.3 新增 ShipConfig 配置表
- `ID`: string - 勘探船ID
- `名称Key`: string
- `描述Key`: string
- `初始血量`: number
- `最大血量`: number
- `每回合震动值增加值`: number

#### 24.8.4 新增 DefenseFacilityConfig 配置表
- `ID`: string - 设施ID
- `名称Key`: string
- `描述Key`: string
- `设施类型`: string
- `初始血量`: number
- `最大血量`: number
- `攻击力`: number
- `攻击范围`: number
- `攻击速度`: number
- `建造消耗资源列表`: string
- `升级消耗资源列表`: string

### 24.9 数据结构扩展

#### 24.9.1 Monster 扩展
```typescript
interface Monster {
  // ... 现有字段 ...
  isInvader?: boolean; // 是否为入侵怪物
  monsterType?: 'melee' | 'ranged'; // 近战或远程
  targetType?: 'ship' | 'facility'; // 攻击目标类型
  currentPosition?: { x: number; y: number }; // 在探索棋盘上的位置
  targetPosition?: { x: number; y: number } | null; // 目标位置
}
```

#### 24.9.2 新增 ProspectingShip
```typescript
interface ProspectingShip {
  shipId: string;
  config: ShipConfigEntry;
  currentHp: number; // 船体当前血量
  maxHp: number; // 船体最大血量
  baseVibrationPerRound: number; // 每回合默认增加的震动值
}
```

#### 24.9.3 新增 DefenseFacility
```typescript
interface DefenseFacility {
  id: string;
  config: DefenseFacilityConfigEntry;
  currentHp: number;
  level: number; // 设施等级
  position: { x: number; y: number }; // 在探索棋盘外围的位置
  lastAttackTime: number; // 上次攻击时间
}
```

#### 24.9.4 新增 InvasionState
```typescript
interface InvasionState {
  isActive: boolean; // 是否正在进行入侵战斗
  invasionMonsters: Map<string, Monster>; // 入侵怪物列表
  facilities: Map<string, DefenseFacility>; // 防御设施列表
  startTime: number; // 入侵开始时间
}
```

### 24.10 UI设计

#### 24.10.1 入侵战斗面板
- **位置**：探索界面左上角固定显示
- **显示内容**：
  - 船体血量条
  - 震动值进度条
  - 入侵状态提示
  - 防御设施列表

#### 24.10.2 防御设施管理面板
- **位置**：弹窗形式，居中显示
- **功能**：
  - 显示现有设施列表
  - 选择设施类型建造
  - 选择建造位置
  - 升级现有设施

---

**文档结束**
